#summary High-precision numerical integration
#labels Featured

As of version 0.5, mpmath contains a module `quad` for high-precision numerical integration (quadrature).

==Tanh-sinh quadrature==

The function `quadts` performs tanh-sinh quadrature (also known as doubly exponential quadrature). Tanh-sinh quadrature is extremely efficient for high-precision integration of analytic functions and, unlike Gauss-Legendre quadrature, tends to work well even when the integrand has (integrable) singularities at the endpoints of the integration interval.

The syntax for integrating a function _f_ between the endpoints _a_ and _b_ is `quadts(f, a, b)`. For example,

{{{
>>> quadts(lambda x: sin(x), 0, pi)
mpf('2.0')
}}}

===High precision===

`quadts` attempts to evaluate the integral to the full working precision (`mpf.dps`). For example, we can try to calculate 100 digits of pi by integrating the area under the half circle arc x^2^ + y^2^ = 1 (y > 0):

{{{
>>> mpf.dps = 100
>>> print quadts(lambda x: 2*sqrt(1 - x**2), -1, 1)
3.141592653589793238462643383279502884197169399375105820974944592307816406286208
998628034825342117068
>>> print pi
3.141592653589793238462643383279502884197169399375105820974944592307816406286208
998628034825342117068
}}}

The tanh-sinh scheme is efficient enough that analytic 100-digit integrals like this one can often be evaluated in less than a second.

===Timing and initialization===

Let's look at the time needed to compute the aforementioned circle integral at various precision levels:

|| *Precision* || *First evaluation* || *Second evaluation* ||
|| 15 || 0.038 s || 0.0080 s ||
|| 50 || 0.52 s || 0.050 s ||
|| 500 || 16.4 s || 0.53 s ||

The second integration at the same precision level is much faster. The reason for this is that the tanh-sinh algorithm must be initalized by computing a set of evaluation points, and this initalization if often more expensive than actually evaluating the integral. mpmath automatically caches all computed nodes to make subsequent integrations faster. However, the cache is lost when Python shuts down, so if you'd frequently like to use mpmath to calculate (say) 1000-digit integrals, you might want to save the nodes to a file. The nodes are stored in a dict `TS_cache` located in the `quad` module, which can be [http://docs.python.org/lib/module-pickle.html pickled] if desired.

===Features and application examples===

You can integrate over infinite or half-infinite intervals:
{{{
>>> print quadts(lambda x: 2/(x**2+1), 0, inf)
3.14159265358979
>>> print quadts(lambda x: exp(-x**2), -inf, inf)**2
3.14159265358979
}}}

Complex integrals are also supported. The next example computes Euler's constant by using Cauchy's integral formula and looking at the pole of the Riemann zeta function at z = 1.

{{{
>>> print 1/(2*pi) * quadts(lambda x: zeta(exp(1j*x)+1), 0, 2*pi)
(0.577215664901533 + 2.16642176957242e-26j)
>>> print euler
0.577215664901533
}}}

Functions with integral representations, such as the gamma function, can be implemented  directly from the definition.

{{{
>>> def Gamma(z):
...     return quadts(lambda t: exp(-t)*t**(z-1), 0, inf)
...
>>> print Gamma(1)
1.0
>>> print Gamma(10)
362880.0
>>> print Gamma(1+1j)
(0.498015668118356 + -0.154949828301811j)
}}}

===Error detection===

The tanh-sinh algorithm is not suitable for adaptive quadrature, and does not perform well if there are singularities between the endpoints or if the integrand is very bumpy or oscillatory (such integrals should manually be split into smaller pieces). If the `error=1` option is set, `quadts` will return an error estimate along with the result; although this estimate is not always correct, it can be useful for debugging.

A simple example where the algorithm fails is the function f(x) = abs(sin(x)), which is not smooth at x = pi. In this case, a close value is calculated, but the result is nowhere near the target accuracy; however, `quadts` gives a good estimate of the magnitude of the error:
{{{
>>> mpf.dps = 15
>>> quadts(lambda x: abs(sin(x)), 0, 2*pi, error=1)
(mpf('3.9990089417677899'), mpf('0.001'))
}}}

Attempting to evaluate oscillatory integrals on large intervals by means of the tanh-sinh method is generally futile. This integral should be pi/2 ~= 1.57:
{{{
>>> print quadts(lambda x: sin(x)/x, 0, inf, error=1)
(mpf('2.3840907358976544'), mpf('1.0'))
}}}

This should be 0.627 but `quadts` generates complete nonsense both in the result and the error estimate (the error estimate is somewhat arbitrarily capped at 1.0):
{{{
>>> print quadts(lambda x: sin(x**2), 0, inf, error=1)
(mpf('2.5190134849122411e+21'), mpf('1.0'))
}}}

However, oscillation may not be a problem if suppressed by sufficiently fast decay. This integral is exactly 1/2.
{{{
>>> print quadts(lambda x: exp(-x)*sin(x), 0, inf)
0.5
}}}

Even for analytic integrals on finite intervals, there is no guarantee that `quadts` will be successful.  A few examples of integrals for which `quadts` currently fails to reach full accuracy are:

{{{
quadts(lambda x: sqrt(tan(x)), 0, pi/2)
quadts(lambda x: atan(x)/(x*sqrt(1-x**2)), 0, 1)
quadts(lambda x: log(1+x**2)/x**2, 0, 1)
quadts(lambda x: x**2/((1+x**4)*sqrt(1-x**4)), 0, 1)
}}}

==Double integrals==

It is possible to calculate double integrals with `quadts`. To do this, simply provide a two-argument function and, instead of two endpoints, provide two intervals. The first interval specifies the range for the x variable and the second interval specifies the range of the y variable.

{{{
>>> print quadts(lambda x, y: cos(x+y/2), (-pi/2, pi/2), (0, pi))
4.0
}}}

===Hard examples===

Here are some more difficult examples from http://mathworld.wolfram.com/DoubleIntegral.html (all except the second contain corner singularities). Each integral is calculated with `mpf.dps = 30` (which takes a couple of seconds), and the result is compared to the known analytical value.

{{{
>>> print quadts(lambda x, y: (x-1)/((1-x*y)*log(x*y)), (0, 1), (0, 1))
0.577215664901532860606512090082
>>> print cgamma
0.577215664901532860606512090082
}}}

{{{
>>> print quadts(lambda x, y: 1/sqrt(1+x**2+y**2), (-1, 1), (-1, 1))
3.17343648530607134219175646705
>>> print 4*log(2+sqrt(3))-2*pi/3
3.17343648530607134219175646705
}}}

{{{
>>> print quadts(lambda x, y: 1/(1-x**2 * y**2), (0, 1), (0, 1))
1.23370055013616982735431137498
>>> print pi**2 / 8
1.23370055013616982735431137498
}}}

{{{
>>> print quadts(lambda x, y: 1/(1-x*y), (0, 1), (0, 1))
1.64493406684822643647241516665
>>> print pi**2 / 6
1.64493406684822643647241516665
}}}

===Examples of failure===

Apparently simple-looking double integrals might not be possible to evaluate directly. In this example, `quadts` will run for several seconds before returning a value with very low accuracy:
{{{
>>> mpf.dps = 15
>>> quadts(lambda x, y: sqrt((x-0.5)**2+(y-0.5)**2), (0, 1), (0, 1), error=1)
(mpf('0.38259743528830826'), mpf('1.0e-6'))
}}}

The problem is due to the non-analytic behavior of the function at (0.5, 0.5). We can do much better by splitting the area into four pieces (because of the symmetry, we only need to evaluate one of them):

{{{
>>> print quadts(lambda x, y: 4*sqrt((x-0.5)**2+(y-0.5)**2), (0.5, 1), (0.5, 1))
0.382597858232106
>>> print (sqrt(2) + asinh(1))/6
0.382597858232106
}}}

The value agrees with the analytic result and the running time in this case is just 0.7 seconds.

===Higher-dimensional integrals===

There is no direct support for computing triple or higher dimensional integrals; if desired, this can be done easily by passing a function that calls `quadts()` recursively. While double integrals are reasonably fast, even a simple triple integral at very low precision will probably take several minutes to calculate. A quadruple integral will require a whole lot of patience.