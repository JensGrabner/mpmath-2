#summary Front page

Mpmath is a [http://www.python.org/ Python] library for arbitrary-precision floating-point arithmetic. It is lightweight (~100 KB), free (BSD license), and easy to install due to being written in pure Python without any external dependencies.

Mpmath offers far better performance than Python's built-in `decimal` library (typically 10-100 times faster). It has full support for complex numbers and implements all the transcendental functions from Python's `math` and `cmath` modules efficiently and with arbitrary precision. Additional features include special functions (`gamma`, `factorial`, `erf`, `zeta`, ...), directed rounding (floor, ceiling, down, up, half-down, half-up, half-even), interval arithmetic, unlimited exponents (no overflow or underflow), and utilities for arbitrary-precision numerical integration.

Mpmath is developed with the goal to provide fast and robust high-precision numerics for the Python computer algebra system [http://code.google.com/p/sympy/ SymPy] (and [http://code.google.com/p/sympycore/ SymPyCore]), but can just as well be used on its own as a simple drop-in replacement for Python's `float` and `complex` types and `math` / `cmath` modules.

Latest updates (see [History] for previous updates):
  * *January 13, 2008.* Released [http://code.google.com/p/mpmath/downloads/list?q=0.6 version 0.6]. A new class (mpi) for interval arithmetic has been added. Rounding for powers has been improved, and infinities/nan are supported in more places. Various small bugs have been fixed, the mpf class implementation has been simplified, and tweaks to the integer bitcount code (among other things) resulted in arithmetic now being about 20-30% faster.
  * *December 8, 2007.* There is now a mailing list: [http://groups.google.com/group/mpmath]. mpmath is also being [http://qa.debian.org/developer.php?login=python-modules-team@lists.alioth.debian.org added to debian] (thanks to [http://matrixhasu.altervista.org/ Sandro Tosi] and the Debian Python Modules Team)

==Installation==
The latest version can be found under "Featured Downloads" on the right of this page. To install mpmath, either run the binary installer (Windows only) or unzip the source package and run `python setup.py install`. The most recent development code is available in the [http://mpmath.googlecode.com/svn/ SVN repository]. Old versions are available from the [http://code.google.com/p/mpmath/downloads/list downloads page].

Debian package information is available at http://packages.debian.org/python-mpmath

==Features and documentation==

===Basic usage===

See the [Documentation] wiki page for a more comprehensive overview.

Importing all contents from the `mpmath` module gives access to the classes `mpf` (for real floating-point numbers) and `mpc` (for complex numbers), as well as a number of functions familiar from Python's `math` and `cmath` modules, including `sqrt`, `exp`, `log`, `power`, `cos`, `sin`, `tan`, `cosh`, `sinh`, `tanh`, `acos`, `asin`, `atan`, `acosh`, `asinh`, `atanh`, `atan2`, `hypot`. A quick demonstration in the interactive Python interpreter:

{{{
>>> from mpmath import *
>>> print mpf('2.5') / mpf('0.1e-5')
2500000.0
>>> sqrt(mpf('1e1000'))  # mpf exponents can be arbitrarily large
mpf('1.0e+500')
>>> mpf.dps = 50   # set precision to 50 decimal places (default is 15)
>>> print exp(1)
2.7182818284590452353602874713526624977572470937
>>> mpf.dps = 20
>>> exp(mpc(real=0, imag=1))   # complex numbers are supported
mpc(real='0.5403023058681397174013', imag='0.8414709848078965066527')
}}}

Suppose you need 250 digits of `1-tanh(pi*sqrt(163))`. Evaluating this expression directly using Python's math functions won't give a single digit since the tanh value differs from 1 by less than 10^-34^. Obtaining a fully accurate value is easy in mpmath by increasing the working precision (the following calculation takes about 2 ms of CPU time):

{{{
>>> mpf.dps = 300
>>> a = tanh(pi*sqrt(163))
>>> mpf.dps = 250
>>> print 1 - a
0.000000000000000000000000000000000029016671556975386379708886075013953233942159
28220961164584196307134531718146007142093177368543313383147966120054717968661325
33092032077098156399455773519701080949781301191960905408797891757218766439604790
9136148524081177295745455524995633685457274904
}}}

===Numerical integration===

Although mpmath is mainly intended to be an arbitrary-precision replacement for Python's `math` and `cmath` modules, some more advanced utilities are available. For example, the `quadts` function computes integrals with arbitrary precision (see the [NumericalIntegration] wiki page for detailed documentation with multiple examples):

{{{
>>> mpf.dps = 100
>>> print quadts(lambda x: 2/(x**2+1), 0, inf)
3.141592653589793238462643383279502884197169399375105820974944592307816406286208
998628034825342117068
}}}

===Interval arithmetic===
The `mpi` type implements interval arithmetic that rigorously tracks error bounds across calculations. See [IntervalArithmetic] for further documentation.
{{{
>>> mpi(4) / 5
[0.79999999999999993339, 0.80000000000000004441]
}}}

===Low-level operations===

Internally, `mpmath` represents floating-point numbers as tuples of integers. The `mpmath.lib` subpackage implements functions for operating directly on such tuples. These functions are much faster than working with `mpf` objects, and can be more convenient if one wants detailed control over precision and rounding.

==Comparison against other Python float libraries==

Both mpmath and Python's built-in [http://docs.python.org/lib/module-decimal.html decimal] library essentially represent numbers as tuples of Python ints, but mpmath uses binary arithmetic which is much more efficient. Typically, mpmath is 10-100 times faster than decimal at low to medium precision levels (and asymptotically even faster). The decimal library also does not implement transcendental functions or complex numbers. Although there are packages for decimal functions (several, in fact), they are all quite slow. For example, a 300-digit logarithm in [http://code.google.com/p/dmath/ dmath] takes 8 seconds, compared to 1 ms in mpmath.

The [Performance] page contains detailed benchmarks, comparing mpmath against Python `Decimals` at various precision levels.

Mpmath may also be benchmarked against [http://code.google.com/p/gmpy/ gmpy] (GMP), which is written in C and hence is quite a bit faster. Arithmetic operations in mpmath are roughly 10-15x slower than gmpy at all precision levels between 1 and 1000 digits; or about 6x slower using [http://psyco.sourceforge.net/ psyco] and `mpmath.lib` functions. However, mpmath has many features that [http://code.google.com/p/gmpy/ gmpy] lacks, such as special functions, complex numbers and directed rounding; mpmath also does not require compilation, and its license is more liberal.

As an order-of-magnitude figure, mpmath can do 100,000 floating-point operations per second at 15-digit precision on a decently modern PC, about 200,000 flops with psyco and 400,000 flops with psyco and mpmath.lib functions. This is fast enough for many purposes -- it depends on the application, of course.

===Extremely high precision===

Mpmath is not really designed for doing calculations with _millions_ of digits (the primary limitation is Python's asymptotically slow integer multiplication and division), but it is possible in principle. Just for entertainment, mpmath includes a demo script [http://mpmath.googlecode.com/svn/trunk/mpmath/apps/pidigits.py pidigits.py] that computes and prints digits of pi in any base 2-36. In round numbers, it can compute and print 10,000 decimals in half a second, 100,000 decimals in 30 seconds and 1,000,000 decimals in 30 minutes.

==Compatibility==

Mpmath can essentially be used as a drop-in replacement for Python's `float`/`complex` types and `math`/`cmath` libraries. In principle, mpmath is able to emulate the precise behavior of IEEE 754 single/double/extended double arithmetic, which could be useful in some applications. Some IEEE 754 features like denormalized numbers are not yet supported, but for normal numbers, arithmetic on mpmath floats at 53-bit precision behaves identically to IEEE double (Python float) arithmetic. The transcendental functions intentionally don't work quite like those in the standard math library, however; mpmath increases the internal precision to accurately evaluate an expression like `sin(10**20)` whereas `math.sin(10**20)` just returns pseudorandom garbage.