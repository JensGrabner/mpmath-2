#summary Front page

http://mpmath.googlecode.com/svn/doc/mpmath-web.png

mpmath is a replacement for Python's `float`/`complex` types and `math`/`cmath` modules with unlimited precision and exponent sizes. It is written entirely in Python without any external dependencies and hence runs almost anywhere, without the need for compilation. Its features include:

  * Arbitrary-precision real and complex floating-point arithmetic
  * Lots of functions: `sqrt`, `exp`, `log`, `power`, `cos`, `sin`, `tan`, `cosh`, `sinh`, `tanh`, `acos`, `asin`, `atan`, `acosh`, `asinh`, `atanh`, `atan2`, `hypot`, `arg`, `gamma`, `factorial`, `erf`, `upper_gamma`/`lower_gamma` (incomplete gamma functions), `zeta`.
  * Common mathematical constants: `e`, `pi`, `cgamma` (Euler's constant)
  * Directed rounding for all arithmetic operations on real numbers, in all directions supported by Python's `decimal` library (floor, ceiling, down, up, half-down, half-up, half-even).

==Installation==

Use the "Featured Downloads" links on the right to download the latest version. To install mpmath, either run the binary installer (Windows only) or unzip the source package and run `python setup.py install`.

The most recent development code is available in the [http://mpmath.googlecode.com/svn/ SVN repository]. Old versions are available from the [http://code.google.com/p/mpmath/downloads/list downloads page].

==Usage==
*Main page: [Documentation]*

mpmath consists of two parts: an internal functional library and a more user-friendly 
interface consisting of the classes `mpf`/`mpc` (similar to Python's standard float and complex types), and standard mathematical functions. Importing directly from `mpmath` gives access to the latter. Here is an example of an interactive session:

{{{
>>> from mpmath import *
>>> mpf.dps = 50   # set precision to 50 decimal places (default is 15)
>>> print exp(1)
2.7182818284590452353602874713526624977572470937
>>> print mpf('2.5') / mpf('0.1e-5')
2500000.0
>>> sqrt(mpf('1e1000'))  # mpf exponents can be arbitrarily large
mpf('1.0e+500')

}}}

==Performance==

  * *Versus decimal*: whereas Python's `decimal` library is primarily designed for correct rounding of decimal fractions, mpmath uses binary numbers for greater speed. mpmath manages roughly 50,000-100,000 arithmetic operations per second with 15-digit precision on a modern PC (~300,000 ops/s with [http://psyco.sourceforge.net/ psyco] enabled and using direct functions), which is an order of magnitude faster than `decimal`. Its performance also scales well with increased precision; the speed is roughly the same at 15 and 150 digits, and multiplication is only 10 times slower at 1000 digits than at 15 digits. At high precision (i.e., hundreds of digits), mpmath is typically a factor 100 or 1000 faster than the `decimal` library.

  * The *[Performance]* page contains detailed benchmarks, comparing mpmath against Python `Decimals` at various precision levels.

  * *Versus gmpy*: Considering that mpmath is written in pure Python, it compares fairly well to [http://code.google.com/p/gmpy/ gmpy] (a Python wrapper for the lightning-fast GNU MP library written in C). Arithmetic with gmpy is roughly 10-25x faster between 10 and 1000 digits, but closer to 5-10x faster if mpmath is allowed to use psyco and direct functions (though, to be fair, enabling psyco for gmpy as well puts the number above 10x).

  * *Extremely high precision*: mpmath is not really designed for doing calculations with millions of digits (the primary limitation is Python's slow integer multiplication and division), but it is possible in principle. Just for entertainment, mpmath includes a demo script [http://mpmath.googlecode.com/svn/trunk/demo/pidigits.py pidigits.py] (in the source distribution) that computes and prints digits of pi in any base 2-36. In round numbers, it can compute 10,000 decimals in half a second, 100,000 decimals in 30 seconds and 1,000,000 decimals in 30 minutes. The large differences between these timings give an indication of the precision range where mpmath ceases to be useful.

==Future development==
Planned future additions include:
  * Emulation of all features defined in the IEEE 754 floating-point standard (support for !NaNs and infinities; optional support for denormalized numbers)
  * Rigorous directed rounding for advanced functions