#summary Front page

mpmath is a replacement for Python's `float`/`complex` types and `math`/`cmath` modules with unlimited precision and exponent sizes. It is written entirely in Python without any external dependencies and hence runs almost everywhere, without the need for compilation.

http://mpmath.googlecode.com/svn/doc/mpmath-web.png

==Status / news==
  * *October 5, 2007.* Released [http://mpmath.googlecode.com/files/mpmath-0.3.zip version 0.3]. All the 12 standard trigonometric, hyperbolic, inverse trigonometric and inverse hyperbolic functions are now available in mpmath and work for both real and complex numbers with arbitrary precision. A few useful nonelementary functions like `gamma`, `erf` and `zeta` have been implemented as well. In addition, numerous bugs have been fixed, more tests have been added, and parts of the code have been cleaned up.
  * *October 2, 2007.* Released [http://mpmath.googlecode.com/files/mpmath-0.2.zip version  0.2]. This version fixes several bugs and adds improved support for complex numbers (complex logarithms and powers are now supported).
  * *September 27, 2007.* Released version 0.1.
  * *September 25, 2007.* Started the Google Code project.

For a detailed changelog, see the [http://mpmath.googlecode.com/svn/trunk/CHANGES CHANGES] file. To summarize, the following features are implemented in the current version:
  * Arbitrary-precision real and complex floating-point arithmetic
  * Lots of functions: `sqrt`, `exp`, `log`, `power`, `cos`, `sin`, `tan`, `cosh`, `sinh`, `tanh`, `acos`, `asin`, `atan`, `acosh`, `asinh`, `atanh`, `atan2`, `hypot`, `arg`, `gamma`, `factorial`, `erf`, `upper_gamma`/`lower_gamma` (incomplete gamma functions), `zeta`.
  * Common mathematical constants: `e`, `pi`, `cgamma` (Euler's constant)
  * Directed rounding for real numbers, in all directions supported by Python's `Decimal` class. (Directed rounding is implemented rigorously for addition and multiplication and heuristically for more advanced operations.)

Planned future additions include:
  * Emulation of all features defined in the IEEE 754 floating-point standard (support for !NaNs and infinities; optional support for denormalized numbers)
  * Rigorous directed rounding for all functions
  * Fast radix conversion

The current development code is available in the [http://mpmath.googlecode.com/svn/ SVN repository].

==Basic usage==

To install mpmath, either run the binary installer (Windows only) or unpack the source distribution and run `python setup.py install`. To import it in an interactive Python session, type

{{{
>>> from mpmath import *
}}}

mpmath provides two classes `mpf` and `mpc` which respectively correspond to Python's built-in `float` and `complex`. They interact nicely with other numbers:

{{{
>>> mpf(3) + 2*mpf('2.5') + 1.0
mpf('9')
>>> mpc(1j)**0.5
mpc(real='0.70710678118654757', imag='0.70710678118654757')
}}}

The `print` statement displays numbers more prettily:
{{{
>>> print mpc(1j)**0.5
(0.707106781186548 + 0.707106781186548j)
}}}

==Managing precision==

As seen above, mpfs have a default precision of roughly 15 decimal digits (more precisely 53 bits), the same as standard floats. To change the precision, use the `prec` or `dps` properties of the `mpf` class. `prec` is the precision in bits and `dps` is the precision in decimals; if you change one, the `mpf` class automatically changes the other to match. For example, this sets the precision to 100 digits:

{{{
>>> mpf.dps = 100
>>> mpf.dps
100
>>> mpf.prec
336
}}}

This increases the precision by two bits and then restores it:
{{{
>>> mpf.prec += 2
>>> mpf.prec -= 2
}}}

When you've set the precision level, all mpf and mpc operations are carried out at that precision:

{{{
>>> mpf.dps = 50
>>> mpf(1) / 7
mpf('0.1428571428571428571428571428571428571428571428571428')
>>> mpf.dps = 100
>>> mpf(2) ** 0.5
mpf('1.4142135623730950488016887242096980785696718753769480731766797379907324784
6210703885038753432764157274')
}}}

There is no practical magnitude limitation on numbers. For example, an mpf can represent an approximation of 1 googolplex:

{{{
>>> a = mpf(10) ** (10**100)
}}}

Unfortunately, in the current version, the above number cannot be printed to a decimal (this will be fixed). You can take its logarithm, however:

{{{
>>> print log(a, 10)
1.00000000000000E+100
}}}

The objects `pi`, `e`, and `cgamma` (Euler's constant) are special objects that behave like mpfs but whose values automatically adjust to the precision.

{{{
>>> mpf.dps = 15
>>> print pi
3.14159265358979
>>> mpf.dps = 50
>>> print pi
3.1415926535897932384626433832795028841971693993751
}}}

==Rounding==

Directed rounding is partially implemented. For example, this computes and verifies a 15-digit approximation interval for pi:

{{{
>>> mpf.dps = 15
>>> mpf.round_down(); pi1 = +pi
>>> mpf.round_up(); pi2 = +pi
>>> pi1
mpf('3.1415926535897931')
>>> pi2
mpf('3.1415926535897936')
>>> mpf.dps = 30
>>> pi1 < pi < pi2
True
}}}

==Performance==

mpmath is roughly 10 times faster than Python's built-in decimal module at standard precision, and increasingly faster at higher precision levels (for example, calculating the 100th harmonic number 1 + 1/2 + ... + 1/100 with 1000-digit precision is 300 times faster in mpmath).

mpmath uses tuples of Python integers to represent floating-point numbers with arbitrary precision. It is relatively slow compared to C/C++ libraries at low precision levels, where Python's interpreter overhead dominates over the time spent on actual arithmetic, and also relatively slow at extremely high precision levels since Python does not use the asymptotically fastest algorithms for large-integer multiplication and division. In between, however, the performance is quite acceptable for many applications. The speed is roughly the same at 15 and 150 digits, and multiplication is only 10 times slower at 1000 digits than at 15 digits.

In the default (most accurate) rounding mode, mpmath manages 50,000-100,000 arithmetic operations per second with 15-digit precision on a modern PC (Athlon 3700+). [http://psyco.sourceforge.net/ Psyco] roughly doubles that number. (Using Psyco and the fastest rounding mode, and using the internal functional interface instead of number objects, some 300,000-800,000 arithmetic operations can be performed per second at 15-digit precision.)

See the [Performance] page for a more detailed benchmark.

Just for entertainment, mpmath includes a demo script pidigits.py (in the source distribution) that computes digits of pi in any base 2-36. Roughly timed, it can compute 10,000 decimals in half a second, 100,000 decimals in 30 seconds and 1,000,000 decimals in 30 minutes. The large differences between these timings give an indication of the precision range where mpmath ceases to be useful.