#summary Front page

http://mpmath.googlecode.com/svn/doc/mpmath-web.png

mpmath is a replacement for Python's `float`/`complex` types and `math`/`cmath` modules with support for unlimited precision and exponent sizes. It is written entirely in Python without any external dependencies and hence runs almost anywhere, without the need for compilation. Its features include:

  * Arbitrary-precision real and complex floating-point arithmetic
  * Lots of functions: `sqrt`, `exp`, `log`, `power`, `cos`, `sin`, `tan`, `cosh`, `sinh`, `tanh`, `acos`, `asin`, `atan`, `acosh`, `asinh`, `atanh`, `atan2`, `hypot`, `arg`, `gamma`, `factorial`, `erf`, `upper_gamma`/`lower_gamma` (incomplete gamma functions), `zeta`.
  * Common mathematical constants: `e`, `pi`, `cgamma` (Euler's constant)
  * Avoids bugs present in Python's `cmath` library, like `asinh` using the wrong branch cut
  * Directed rounding for all arithmetic operations on real numbers, in all directions supported by Python's `decimal` library (floor, ceiling, down, up, half-down, half-up, half-even).

Latest update (see [History] for previous updates):

  * *November 3, 2007.* Released [http://code.google.com/p/mpmath/downloads/list?q=0.4 version 0.4]. String conversion has been rewritten to use integer arithmetic instead of Decimals, which makes it an order of magnitude faster; basic arithmetic speed has also been improved by 15%. Division now uses a rigorous algorithm for directed rounding (it previously got the last bit wrong with a 0.01% probability). Some functions have been added or renamed, and the unit tests have been made more exhaustive.

==Download / Installation==

Use the "Featured Downloads" links on the right to download the latest version. To install mpmath, either run the binary installer (Windows only) or unzip the source package and run `python setup.py install`.

The most recent development code is available in the [http://mpmath.googlecode.com/svn/ SVN repository]. Old versions are available from the [http://code.google.com/p/mpmath/downloads/list downloads page].

==Usage==
*Main page: [Documentation]*

Importing directly from `mpmath` gives access to a user-friendly interface similar to using regular Python floats and the `math`/`cmath` modules. The class `mpf` represents a real floating-point number and the class `mpc` represents a complex number. Here is an example of an interactive session:

{{{
>>> from mpmath import *
>>> print mpf('2.5') / mpf('0.1e-5')
2500000.0
>>> sqrt(mpf('1e1000'))  # mpf exponents can be arbitrarily large
mpf('1.0e+500')
>>> mpf.dps = 50   # set precision to 50 decimal places (default is 15)
>>> print exp(1)
2.7182818284590452353602874713526624977572470937
>>> mpf.dps = 20
>>> exp(mpc(real=0, imag=1))   # complex numbers are supported
mpc(real='0.5403023058681397174013', imag='0.8414709848078965066527')
}}}

Internally, `mpmath` represents floating-point numbers as tuples of integers. The `mpmath.lib` subpackage implements functions for operating directly on such tuples. Although verbose, these functions are faster than working with `mpf` objects, and can be more convenient if one wants detailed control over precision and rounding. The following example shows how to compute an approximation interval for 1/3 with 20-bit (~6 decimals) precision:

{{{
>>> from mpmath.lib import *
>>> a = from_int_exact(1)
>>> b = from_int_exact(3)
>>> to_str(fdiv(a, b, prec=20, rounding=ROUND_DOWN), 10)
'0.3333330154'
>>> to_str(fdiv(a, b, prec=20, rounding=ROUND_UP), 10)
'0.3333334923'
}}}

==Performance==

  * *Versus decimal*: whereas Python's `decimal` library is primarily designed for exact representation of decimal fractions, mpmath uses binary numbers for greater speed. mpmath manages roughly 50,000-100,000 arithmetic operations per second with 15-digit precision on a modern PC (~300,000 ops/s with [http://psyco.sourceforge.net/ psyco] enabled and using direct functions on tuples), which is an order of magnitude faster than `decimal`. Its performance also scales well with increased precision; the speed is roughly the same at 15 and 150 digits, and multiplication is only 10 times slower at 1000 digits than at 15 digits. At high precision (i.e., hundreds of digits), mpmath is typically a factor 100 or 1000 faster than the `decimal` library.

  * The *[Performance]* page contains detailed benchmarks, comparing mpmath against Python `Decimals` at various precision levels.

  * *Versus gmpy*: Considering that mpmath is written in pure Python, it compares fairly well to [http://code.google.com/p/gmpy/ gmpy] (a Python wrapper for the lightning-fast GNU MP library). Arithmetic in gmpy is roughly 10-25x faster between 10 and 1000 digits, but closer to being only 5-10x faster if mpmath is allowed to use psyco and direct functions (around 10x faster if, to be fair, gmpy is allowed to use psyco as well).

  * *Extremely high precision*: mpmath is not really designed for doing calculations with millions of digits (the primary limitation is Python's slow integer multiplication and division), but it is possible in principle. Just for entertainment, mpmath includes a demo script [http://mpmath.googlecode.com/svn/trunk/demo/pidigits.py pidigits.py] (in the source distribution) that computes and prints digits of pi in any base 2-36. In round numbers, it can compute 10,000 decimals in half a second, 100,000 decimals in 30 seconds and 1,000,000 decimals in 30 minutes. The large differences between these timings give an indication of the precision range where mpmath ceases to be useful.

==Future development==
Planned future additions include:
  * Emulation of all features defined in the IEEE 754 floating-point standard (support for !NaNs and infinities; optional support for denormalized numbers)
  * Rigorous directed rounding for advanced functions