#summary Interval arithmetic

The next version of mpmath will feature interval arithmetic (this document is a draft).

==Working with mpi instances=

You can create an `mpi` from a number (treated as a zero-width interval) or a pair of numbers. Strings are treated as exact decimal numbers (note that a Python float like 0.1 generally does not represent the same number as its literal; use "0.1" instead).

{{{
>>> mpi(3)
[3, 3]
>>> mpi(2, 3)
[2, 3]
>>> mpi(0.1)  # probably not what you want
[0.10000000000000000555, 0.10000000000000000555]
>>> mpi('0.1')  # good
[0.099999999999999991673, 0.10000000000000000555]
}}}

The fact that '0.1' results in an interval of nonzero width proves that 0.1 cannot be represented using binary floating-point numbers at this precision level (in fact, it cannot be represented exactly at any precision).

Interval arithmetic uses the same precision as the `mpf` class; if `mpf.dps = 50` is set, all interval operations will be carried out with 50-digit precision. Of course, interval arithmetic is guaranteed to give correct bounds at any precision, but a higher precision makes the intervals narrower and hence more accurate.

==Example arithmetic==
Division is generally not an exact operation in floating-point arithmetic. Using interval arithmetic, we can track both the error from the division and the error that propagates if we follow up with the inverse operation:

{{{
>>> 1 / mpi(3)
[0.33333333333333331483, 0.33333333333333337034]
>>> 1 / (1 / mpi(3))
[2.9999999999999995559, 3.0000000000000004441]
}}}

The same goes for computing square roots:
{{{
>>> (mpi(2) ** 0.5) ** 2
[1.9999999999999993339, 2.0000000000000004441]
}}}

By design, interval arithmetic propagates errors, no matter how tiny, that would get rounded off in normal floating-point arithmetic.
{{{
>>> mpi(1) + mpi('1e-10000')
[1.0, 1.000000000000000222]
}}}

The [Documentation] page shows that 1 googolplex, 10e(10^100^), can be represented approximately by an `mpf`. In fact, the approximation is surprisingly poor in some respects: at 15-digit precision, 15 digits are not even sufficient for representing the exact integer value of the 100-digit exponent. Interval arithmetic shows this phenomenon quite clearly:

{{{
>>> mpi(10) ** (10**100)
[8.764150614478983589e+999999999999999577937442449244650288135906221600843613734
4172525418802729006627916222015405100151261, 7.0824128566848680891e+100000000000
00002528897464962343855885068477784526843237045844382284543847321520815234855350
460857113]
}}}

The interval mantissa does not contain a single correct digit, but ~15 digits are encoded in the exponents, which are correctly rounded up and down. In conclusion, interval arithmetic has no problem coping with numbers whose size may cause accuracy problems in ordinary floating-point arithmetic.

==Proving inequalities==
Can we use interval arithmetic to prove the inequality `exp(pi*sqrt(163)) < 640320**3 + 744`? The left-hand and right-hand sides agree to over 30 digits, so low-precision arithmetic may give the wrong result:

{{{
>>> mpf.dps = 25
>>> exp(pi*sqrt(163)) < (640320**3 + 744)
False
}}}

To get the right answer, we can use interval arithmetic to check whether the difference between the two numbers is negative. Interval arithmetic does not tell us the answer right away, but it is honest enough to tell us that:

{{{
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-0.0000007934868335723876953125, 0.000000946223735809326171875]
}}}

There is both a negative and a positive endpoint, so we cannot tell for certain whether the true difference is on one side or the other of zero. The solution is to increase the precision until the answer is strictly one-signed:

{{{
>>> mpf.dps = 35
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-7.499745182520944908333149214740842580795e-13, -7.4986067702398351286774413892
99929141998e-13]
}}}

==Special functions==
So far, only the arithmetic operators `+, -, *, /` are fully supported by intervals. Powers (`**`) are supported only in the basic case of both numbers being positive, and are currently not guaranteed to give correct results in all cases (an error should require some effort to find, though!).

It would obviously be nice if you could calculate functions like `exp`, `log`, `sin`, `tan`, etc. Besides being able to ensure full accuracy for high-precision input, the implementation should be smart enough that, for instance, `cos` of an interval wider than 2*pi reduces to [-1, 1]. Transcendental interval functions are planned, but getting them right will require some effort.