#summary Interval arithmetic

The next version of mpmath will feature interval arithmetic (this document is a draft).

==Working with mpi instances=

You can create an `mpi` from a number (treated as a zero-width interval) or a pair of numbers. Strings are treated as exact decimal numbers (note that a Python float like 0.1 generally does not represent the same number as its literal; use "0.1" instead).

{{{
>>> mpi(3)
[3, 3]
>>> mpi(2, 3)
[2, 3]
>>> mpi(0.1)  # probably not what you want
[0.10000000000000000555, 0.10000000000000000555]
>>> mpi('0.1')  # good
[0.099999999999999991673, 0.10000000000000000555]
}}}

The fact that '0.1' results in an interval of nonzero width proves that 0.1 cannot be represented using binary floating-point numbers at this precision level (in fact, it cannot be represented exactly at any precision).

Interval arithmetic uses the same precision as the `mpf` class; if `mpf.dps = 50` is set, all interval operations will be carried out with 50-digit precision. Of course, interval arithmetic is guaranteed to give correct bounds at any precision, but a higher precision makes the intervals narrower and hence more accurate.

==Example arithmetic==
Division is generally not an exact operation in floating-point arithmetic. Using interval arithmetic, we can track both the error from the division and the error that propagates if we follow up with the inverse operation:

{{{
>>> 1 / mpi(3)
[0.33333333333333331483, 0.33333333333333337034]
>>> 1 / (1 / mpi(3))
[2.9999999999999995559, 3.0000000000000004441]
}}}

The same goes for computing square roots:
{{{
>>> (mpi(2) ** 0.5) ** 2
[1.9999999999999993339, 2.0000000000000004441]
}}}

By design, interval arithmetic propagates errors, no matter how tiny, that would get rounded off in normal floating-point arithmetic.
{{{
>>> mpi(1) + mpi('1e-10000')
[1.0, 1.000000000000000222]
}}}

The [Documentation] page shows that 1 googolplex, 10e(10^100^), can be represented approximately by an `mpf`. Using intervals, the absolute error is seen to be quite big:

{{{
>>> mpi(10) ** (10**100)
[9.9999999999999991279e+99999999999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999, 1.0000000000000000241e+10000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000]
}}}

Intervals may be infinite or half-infinite:
{{{
>>> 1 / mpi(2, inf)
[0.0, 0.5]
}}}

The `in` operator tests whether a number or interval is contained in another interval:
{{{
>>> mpi(0, 2) in mpi(0, 10)
True
>>> 3 in mpi(-inf, 0)
False
}}}

==Establishing inequalities==
Interval arithmetic can be used to establish inequality like `exp(pi*sqrt(163)) < 640320**3 + 744`? The left-hand and right-hand sides in this equation agree to over 30 digits, so low-precision arithmetic may give the wrong result:

{{{
>>> mpf.dps = 25
>>> exp(pi*sqrt(163)) < (640320**3 + 744)
False
}}}

The answer should be True, but the rounding errors are larger than the difference between the numbers. To get the right answer, we can use interval arithmetic to check whether the difference between the two sides of the equation. Interval arithmetic does not tell us the answer right away if we keep mpf.dps = 25, but it is honest enough to admit it:

{{{
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-0.0000007934868335723876953125, 0.000000946223735809326171875]
}}}

There is both a negative and a positive endpoint, so we cannot tell for certain whether the true difference is on one side or the other of zero. The solution is to increase the precision until the answer is strictly one-signed:

{{{
>>> mpf.dps = 35
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-7.499745182520944908333149214740842580795e-13, -7.4986067702398351286774413892
99929141998e-13]
}}}

==Special functions==
So far, only the arithmetic operators `+, -, *, /` are fully supported by intervals. Powers (`**`) are supported only in the basic case of both numbers being positive, and are currently not guaranteed to give correct results in all cases (an error should require some effort to find, though!).

It would obviously be nice if you could calculate functions like `exp`, `log`, `sin`, `tan`, etc. Besides being able to ensure full accuracy for high-precision input, the implementation should be smart enough that, for instance, `cos` of an interval wider than 2*pi reduces to [-1, 1]. Transcendental interval functions are planned, but will require some work to make robust.