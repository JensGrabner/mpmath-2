#summary Interval arithmetic

The next version of mpmath will feature interval arithmetic (this document is a draft).

==Working with mpi instances=

You can create an `mpi` from a number (treated as a zero-width interval) or a pair of numbers. Strings are treated as exact decimal numbers (note that a Python float like 0.1 generally does not represent the same number as its literal; use "0.1" instead).

{{{
>>> mpi(3)
[3, 3]
>>> mpi(2, 3)
[2, 3]
>>> mpi(0.1)  # probably not what you want
[0.10000000000000000555, 0.10000000000000000555]
>>> mpi('0.1')  # good
[0.099999999999999991673, 0.10000000000000000555]
}}}

The fact that '0.1' results in an interval of nonzero width proves that 0.1 cannot be represented using binary floating-point numbers at this precision level (in fact, it cannot be represented exactly at any precision).

Interval arithmetic uses the same precision as the `mpf` class; if `mpf.dps = 50` is set, all interval operations will be carried out with 50-digit precision. Of course, interval arithmetic is guaranteed to give correct bounds at any precision, but a higher precision makes the intervals narrower and hence more accurate.

==Example arithmetic==
Division is generally not an exact operation in floating-point arithmetic. Using interval arithmetic, we can track both the error from the division and the error that propagates if we follow up with the inverse operation:

{{{
>>> 1 / mpi(3)
[0.33333333333333331483, 0.33333333333333337034]
>>> 1 / (1 / mpi(3))
[2.9999999999999995559, 3.0000000000000004441]
}}}

The same goes for computing square roots:
{{{
>>> (mpi(2) ** 0.5) ** 2
[1.9999999999999993339, 2.0000000000000004441]
}}}

By design, interval arithmetic propagates errors, no matter how tiny, that would get rounded off in normal floating-point arithmetic.
{{{
>>> mpi(1) + mpi('1e-10000')
[1.0, 1.000000000000000222]
}}}

The [Documentation] page shows that 1 googolplex, 10e(10^100^), can be represented approximately by an `mpf`. Using intervals, the absolute error is seen to be quite big:

{{{
>>> mpi(10) ** (10**100)
[9.9999999999999991279e+99999999999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999, 1.0000000000000000241e+10000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000]
}}}

Intervals may be infinite or half-infinite:
{{{
>>> 1 / mpi(2, inf)
[0.0, 0.5]
}}}

The `in` operator tests whether a number or interval is contained in another interval:
{{{
>>> mpi(0, 2) in mpi(0, 10)
True
>>> 3 in mpi(-inf, 0)
False
}}}

==Establishing inequalities==
Interval arithmetic can be used to establish inequality like `exp(pi*sqrt(163)) < 640320**3 + 744`? The left-hand and right-hand sides in this equation agree to over 30 digits, so low-precision arithmetic may give the wrong result:

{{{
>>> mpf.dps = 25
>>> exp(pi*sqrt(163)) < (640320**3 + 744)
False
}}}

The answer should be True, but the rounding errors are larger than the difference between the numbers. To get the right answer, we can use interval arithmetic to check whether the difference between the two sides of the equation. Interval arithmetic does not tell us the answer right away if we keep mpf.dps = 25, but it is honest enough to admit it:

{{{
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-0.0000007934868335723876953125, 0.000000946223735809326171875]
}}}

There is both a negative and a positive endpoint, so we cannot tell for certain whether the true difference is on one side or the other of zero. The solution is to increase the precision until the answer is strictly one-signed:

{{{
>>> mpf.dps = 35
>>> mpi(e) ** (mpi(pi) * mpi(163)**0.5) - (640320**3 + 744)
[-7.499745182520944908333149214740842580795e-13, -7.4986067702398351286774413892
99929141998e-13]
}}}

==Special functions==
So far, only the arithmetic operators `+, -, *, /` are fully supported by intervals. Powers (`**`) are supported only in the basic case of both numbers being positive, and are currently not guaranteed to give correct results in all cases (an error should require some effort to find, though!).

It would obviously be nice if you could calculate functions like `exp`, `log`, `sin`, `tan`, etc. Besides being able to ensure full accuracy for high-precision input, the implementation should be smart enough that, for instance, `cos` of an interval wider than 2*pi reduces to [-1, 1]. Transcendental interval functions are planned, but will require some work to make both robust and efficient.

==Taylor series demo==
The demo file [http://mpmath.googlecode.com/svn/trunk/mpmath/apps/taylordemo.py taylordemo.py] included in mpmath uses interval arithmetic to demonstrate rounding and truncation error of Taylor series. (Rounding error is the result of performing arithmetic with finitely many digits. Truncation error is the error from truncating an infinite Taylor series after only a finite number of terms. The total error is the sum of the rounding and truncation error.)

The function exponential(x, n) computes exp(x) using n terms of the Taylor series. It sums the series using interval arithmetic to estimate the accumulated rounding error, and then computes an analytic upper estimate of the truncation error using the Lagrange remainder formula.

For example, we can try computing exp(2). If we use n = 5 terms, we get the following results:

{{{
>>> exponential(2, 5)
Correct value:        7.38905609893065
Computed midpoint:    7.26666666666667
Computed interval:    [7.2666666666666657193, 7.2666666666666683838]
Est rounding error:   2.66453525910038e-15
Est truncation error: 0.656804986571613
Est error:            0.656804986571616
Actual error          0.122389432263983
}}}

The rounding error (3e-15) is small, but the truncation error (0.7) is very large due to the small number of terms. Note that the estimated error is larger than the actual error: this should be expected -- for all values of x and n -- since interval arithmetic is conservative (if the error estimate turned out to small, it would be a bug in the mpmath interval arithmetic or in taylordemo.py).

If we try with n = 25, the computed value is more accurate:

{{{
>>> exponential(2, 25)
Correct value:        7.38905609893065
Computed midpoint:    7.38905609893065
Computed interval:    [7.3890560989306424133, 7.3890560989306628414]
Est rounding error:   2.04281036531029e-14
Est truncation error: 1.22956027743875e-18
Est error:            2.04293332133803e-14
Actual error          1.77635683940025e-15
}}}

Note that the rounding error has become larger than the truncation error. In general, summing more terms from the Taylor series results in a smaller truncation error but a larger rounding error, and the best result (for both efficiency and accuracy) is obtained by finding the crossing point that minimizes their sum. Including a ridiculous number of terms makes the truncation error astronomically small, but the rounding errors nonetheless make us start losing accurate digits:

{{{
>>> exponential(2, 50000)
Correct value:        7.38905609893065
Computed midpoint:    7.38905609895285
Computed interval:    [7.3890560989306424133, 7.389056098975049558]
Est rounding error:   4.44071446281669e-11
Est truncation error: 2.79078364936534e-198189
Est error:            4.44071446281669e-11
Actual error          2.21955787083061e-11
}}}