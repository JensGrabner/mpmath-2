#summary Documentation for using mpmath
#labels Featured

This page contains an introduction to mpmath. It does not cover all features. Most mpmath modules contain a fair amount of comments and docstrings, however, so it should be fairly easy to figure out how to use something by looking at the source code, or by looking at the [http://mpmath.googlecode.com/svn/trunk/tests/ unit tests].

==Basic usage==

To import mpmath in an interactive Python session, type

{{{
>>> from mpmath import *
}}}

mpmath provides two classes `mpf` and `mpc` which respectively correspond to Python's built-in `float` and `complex`. They interact nicely with other numbers:

{{{
>>> mpf(3) + 2*mpf('2.5') + 1.0
mpf('9')
>>> mpc(1j)**0.5
mpc(real='0.70710678118654757', imag='0.70710678118654757')
}}}

The `print` statement displays numbers more prettily:
{{{
>>> print mpc(1j)**0.5
(0.707106781186548 + 0.707106781186548j)
}}}

==Managing precision==

As seen above, mpfs have a default precision of roughly 15 decimal digits (more precisely 53 bits), the same as standard floats. To change the precision, use the `prec` or `dps` properties of the `mpf` class. `prec` is the precision in bits and `dps` is the precision in decimals; if you change one, the `mpf` class automatically changes the other to match. For example, this sets the precision to 100 digits:

{{{
>>> mpf.dps = 100
>>> mpf.dps
100
>>> mpf.prec
336
}}}

This increases the precision by two bits and then restores it:
{{{
>>> mpf.prec += 2
>>> mpf.prec -= 2
}}}

When you've set the precision level, all mpf and mpc operations are carried out at that precision:

{{{
>>> mpf.dps = 50
>>> mpf(1) / 7
mpf('0.1428571428571428571428571428571428571428571428571428')
>>> mpf.dps = 100
>>> mpf(2) ** 0.5
mpf('1.4142135623730950488016887242096980785696718753769480731766797379907324784
6210703885038753432764157274')
}}}

There is no practical magnitude limitation on numbers. For example, an mpf can represent an approximation of 1 googolplex (note: you need to use the latest development version from the SVN repository for the printing to work):

{{{
>>> a = mpf(10) ** (10**100)
>>> print a
1.0e+100000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000
>>> print log(a, 10)
1.0e+100
}}}

The objects `pi`, `e`, and `cgamma` (Euler's constant) are special objects that behave like mpfs but whose values automatically adjust to the precision.

{{{
>>> mpf.dps = 15
>>> print pi
3.14159265358979
>>> mpf.dps = 50
>>> print pi
3.1415926535897932384626433832795028841971693993751
}}}

==Rounding==

Directed rounding is partially implemented. For example, this computes and verifies a 15-digit approximation interval for pi:

{{{
>>> mpf.dps = 15
>>> mpf.round_down(); pi1 = +pi
>>> mpf.round_up(); pi2 = +pi
>>> pi1
mpf('3.1415926535897931')
>>> pi2
mpf('3.1415926535897936')
>>> mpf.dps = 30
>>> pi1 < pi < pi2
True
}}}

==Internal number representation==
A binary floating-point number is an exact rational number of the form `x` = `man` Ã— 2^exp^ where `man` and `exp` are integers (called the _mantissa_ and _exponent_). In `mpmath`, a floating-point number is represented as a three-element tuple

    `(man, exp, bc)`

where `bc` is the number of bits in the mantissa. (The `bc` element is strictly speaking redundant since one can re-count the number of bits in the mantissa at any time, but the bitcounts are frequently needed for internal computations and storing them significantly improves performance.) There is one additional requirement for the representation: `man` must have no trailing zero bits (i.e., all powers of two must be factored out and stored in `exp`). This normalization ensures that two floating-point numbers are mathematically equal if and only if their tuple representations are equal, meaning that one can check the equality of two numbers by a simple tuple comparison.

Some examples of floating-point numbers in this format are:

    `1   = (1, 0, 1)`

    `2   = (1, 1, 1)`

    `10  = (5, 1, 3)`

    `0.5 = (1, -1, 1)`

By convention, 0 is taken to have the representation `(0, 0, 0)`.

The modules in the `mpmath.lib` directory contain functions for working directly with tuples. In general, these functions accept as input one or two operands, followed by an option `prec` that specifies the precision and `rounding` that specifies the direction of rounding. For example, to add the numbers 2 and 10, we can use the `fadd` function:

{{{
>>> from mpmath.lib import *
>>> two = (1, 1, 1)
>>> ten = (5, 1, 3)
>>> twelve = fadd(two, ten, 10, ROUND_FLOOR)
>>> twelve
(3, 2, 2)
}}}

Of course, since this sum can be represented exactly with only 10 bits in the mantissa, no rounding was performed.