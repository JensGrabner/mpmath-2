<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mathematical functions &mdash; mpmath v0.10-svn documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <style>img {vertical-align: middle; }</style>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '',
          VERSION:     '0.10-svn',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="mpmath v0.10-svn documentation" href="index.html" />
    <link rel="next" title="Numerical calculus" href="calculus.html" />
    <link rel="prev" title="Mpmath basics" href="basics.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="calculus.html" title="Numerical calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Mpmath basics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="mathematical-functions">
<h1><a class="toc-backref" href="#id1">Mathematical functions<a class="headerlink" href="#mathematical-functions" title="Permalink to this headline">¶</a></a></h1>
<p>Mpmath implements the standard functions from Python&#8217;s <tt class="docutils literal"><span class="pre">math</span></tt> and <tt class="docutils literal"><span class="pre">cmath</span></tt> modules, for both real and complex numbers and with arbitrary precision. Many other functions are also available in mpmath, including commonly-used variants of standard functions (such as the alternative trigonometric functions sec, csc, cot), but also a large number of &#8220;special functions&#8221; such as the gamma function, the Riemann zeta function, error functions, Bessel functions, etc.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#mathematical-functions" id="id1">Mathematical functions</a><ul>
<li><a class="reference internal" href="#constants" id="id2">Constants</a></li>
<li><a class="reference internal" href="#number-parts" id="id3">Number parts</a></li>
<li><a class="reference internal" href="#powers-and-logarithms" id="id4">Powers and logarithms</a></li>
<li><a class="reference internal" href="#trigonometric-functions" id="id5">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-functions" id="id6">Hyperbolic functions</a></li>
<li><a class="reference internal" href="#exponential-integrals" id="id7">Exponential integrals</a></li>
<li><a class="reference internal" href="#bessel-and-related-functions" id="id8">Bessel and related functions</a></li>
<li><a class="reference internal" href="#gamma-and-related-functions" id="id9">Gamma and related functions</a></li>
<li><a class="reference internal" href="#riemann-zeta-function-bernoulli-numbers-and-related" id="id10">Riemann zeta function, Bernoulli numbers and related</a></li>
<li><a class="reference internal" href="#hypergeometric-functions" id="id11">Hypergeometric functions</a></li>
<li><a class="reference internal" href="#elliptic-functions" id="id12">Elliptic functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="constants">
<h2><a class="toc-backref" href="#id2">Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></a></h2>
<p>The predefined objects <tt class="xref docutils literal"><span class="pre">j</span></tt> (imaginary unit), <tt class="xref docutils literal"><span class="pre">inf</span></tt> (positive infinity) and <tt class="xref docutils literal"><span class="pre">nan</span></tt> (not-a-number) are shortcuts to <tt class="xref docutils literal"><span class="pre">mpc</span></tt> and <tt class="xref docutils literal"><span class="pre">mpf</span></tt> instances with these fixed values.</p>
<p>Mpmath supports arbitrary-precision computation of various common (and less common) mathematical constants. These constants are implemented as lazy objects that can be computed with any precision. Whenever the objects are used as function arguments or as operands in arithmetic operations, they automagically evaluate to the current working precision. A lazy number can be converted to a regular <tt class="docutils literal"><span class="pre">mpf</span></tt> using the unary <tt class="docutils literal"><span class="pre">+</span></tt> operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span>
<span class="go">&lt;pi: 3.14159~&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span>
<span class="go">mpf(&#39;6.2831853071795862&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">pi</span>
<span class="go">mpf(&#39;3.1415926535897931&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span>
<span class="go">&lt;pi: 3.14159~&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span>
<span class="go">mpf(&#39;6.283185307179586476925286766559005768394338&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">pi</span>
<span class="go">mpf(&#39;3.141592653589793238462643383279502884197169&#39;)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="mpmath.functions.pi">
<!--[mpmath.functions.pi]--><tt class="descclassname">functions.</tt><tt class="descname">pi</tt><a class="headerlink" href="#mpmath.functions.pi" title="Permalink to this definition">¶</a></dt>
<dd><p><img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" />, roughly equal to 3.141592654, represents the area of the unit
circle, the half-period of trigonometric functions, and many other
things in mathematics.</p>
<p>Mpmath can evaluate <img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" /> to arbitrary precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span>
<span class="go">3.1415926535897932384626433832795028841971693993751</span>
</pre></div>
</div>
<p>This shows digits 99991-100000 of <img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">pi</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;5549362464&#39;</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">pi</span></tt> always rounds to the nearest floating-point
number when used. This means that exact mathematical identities
involving <img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" /> will generally not be preserved in floating-point
arithmetic. In particular, multiples of <tt class="xref docutils literal"><span class="pre">pi</span></tt> (except for 
the trivial case <tt class="docutils literal"><span class="pre">0*pi</span></tt>) are <em>not</em> the exact roots of
<tt class="xref docutils literal"><span class="pre">sin()</span></tt>, but differ roughly by the current epsilon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">mpf(&#39;1.2246467991473532e-16&#39;)</span>
</pre></div>
</div>
<p>One solution is to use the <tt class="xref docutils literal"><span class="pre">sinpi()</span></tt> function instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sinpi</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
</pre></div>
</div>
<p>See the documentation of trigonometric functions for additional
details.</p>
</dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.degree">
<!--[mpmath.functions.degree]--><tt class="descclassname">functions.</tt><tt class="descname">degree</tt><a class="headerlink" href="#mpmath.functions.degree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.e">
<!--[mpmath.functions.e]--><tt class="descclassname">functions.</tt><tt class="descname">e</tt><a class="headerlink" href="#mpmath.functions.e" title="Permalink to this definition">¶</a></dt>
<dd><p>The transcendental number <img src="_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" /> = 2.718281828... is the base of the
natural logarithm (<tt class="xref docutils literal"><span class="pre">ln()</span></tt>) and of the exponential function
(<tt class="xref docutils literal"><span class="pre">exp()</span></tt>).</p>
<p>Mpmath can be evaluate <img src="_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" /> to arbitrary precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span>
<span class="go">2.7182818284590452353602874713526624977572470937</span>
</pre></div>
</div>
<p>This shows digits 99991-100000 of <img src="_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;2100427165&#39;</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">e</span></tt> always rounds to the nearest floating-point number
when used, and mathematical identities involving <img src="_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" /> may not
hold in floating-point arithmetic. For example, <tt class="docutils literal"><span class="pre">ln(e)</span></tt>
might not evaluate exactly to 1.</p>
<p>In particular, don&#8217;t use <tt class="docutils literal"><span class="pre">e**x</span></tt> to compute the exponential
function. Use <tt class="docutils literal"><span class="pre">exp(x)</span></tt> instead; this is both faster and more
accurate.</p>
</dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.phi">
<!--[mpmath.functions.phi]--><tt class="descclassname">functions.</tt><tt class="descname">phi</tt><a class="headerlink" href="#mpmath.functions.phi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.euler">
<!--[mpmath.functions.euler]--><tt class="descclassname">functions.</tt><tt class="descname">euler</tt><a class="headerlink" href="#mpmath.functions.euler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.catalan">
<!--[mpmath.functions.catalan]--><tt class="descclassname">functions.</tt><tt class="descname">catalan</tt><a class="headerlink" href="#mpmath.functions.catalan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.apery">
<!--[mpmath.functions.apery]--><tt class="descclassname">functions.</tt><tt class="descname">apery</tt><a class="headerlink" href="#mpmath.functions.apery" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.khinchin">
<!--[mpmath.functions.khinchin]--><tt class="descclassname">functions.</tt><tt class="descname">khinchin</tt><a class="headerlink" href="#mpmath.functions.khinchin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.glaisher">
<!--[mpmath.functions.glaisher]--><tt class="descclassname">functions.</tt><tt class="descname">glaisher</tt><a class="headerlink" href="#mpmath.functions.glaisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Glaisher&#8217;s constant <img src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" />, also known as the Glaisher-Kinkelin
constant, is a number approximately equal to 1.282427129 that
sometimes appears in formulas related to gamma and zeta functions.</p>
<p>It is defined as <img src="_images/math/ca366fb250c213a523d294a283999904601f0c43.png" alt="A = \exp(1/12-\zeta'(-1))" />. Here <img src="_images/math/ce75e53a83aafa6697a9648449aca4193ef9a060.png" alt="\zeta'(s)" />
denotes the derivative of the Riemann zeta function (see
<tt class="xref docutils literal"><span class="pre">zeta()</span></tt>).</p>
<p>Mpmath can evaluate Glaisher&#8217;s constant to arbitrary precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">glaisher</span>
<span class="go">1.282427129100622636875342568869791727767688927325</span>
</pre></div>
</div>
<p>We can verify that the value computed by <tt class="xref docutils literal"><span class="pre">glaisher</span></tt> is
correct using mpmath&#8217;s facilities for numerical
differentiation and arbitrary evaluation of the zeta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">12</span> <span class="o">-</span> <span class="n">diff</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">))</span>
<span class="go">1.282427129100622636875342568869791727767688927325</span>
</pre></div>
</div>
<p>Here is an example of an integral that can be evaluated in
terms of Glaisher&#8217;s constant:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">-0.0428537406502909</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">7</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="o">/</span><span class="mf">24</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mf">4</span> <span class="o">+</span> <span class="mf">3</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">glaisher</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span>
<span class="go">-0.042853740650291</span>
</pre></div>
</div>
<p>Mpmath computes Glaisher&#8217;s constant by applying Euler-Maclaurin
summation to a slowly convergent series. The implementation is
reasonably efficient up to about 10,000 digits. See the source
code for additional details.</p>
<p>References:
<a class="reference external" href="http://mathworld.wolfram.com/Glaisher-KinkelinConstant.html">http://mathworld.wolfram.com/Glaisher-KinkelinConstant.html</a></p>
</dd></dl>

</div>
<div class="section" id="number-parts">
<h2><a class="toc-backref" href="#id3">Number parts<a class="headerlink" href="#number-parts" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.fabs">
<!--[mpmath.functions.fabs]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fabs</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.fabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute value of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/49428192d366caf373c0af3c3261687f12b4c883.png" alt="|x|" />. Unlike <tt class="xref docutils literal"><span class="pre">abs()</span></tt>,
<tt class="xref docutils literal"><span class="pre">fabs()</span></tt> converts non-mpmath numbers (such as <tt class="docutils literal"><span class="pre">int</span></tt>)
into mpmath numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fabs</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fabs</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fabs</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;5.0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.re">
<!--[mpmath.functions.re]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">re</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.re" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the real part of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/b997fd37cd7877511801547e80ebbf1f1542e0c9.png" alt="\Re(x)" />. Unlike <tt class="docutils literal"><span class="pre">x.real</span></tt>,
<tt class="xref docutils literal"><span class="pre">re()</span></tt> converts <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> to a mpmath number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;-1.0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.im">
<!--[mpmath.functions.im]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">im</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.im" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the imaginary part of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/836603b7b4095dd04119fbfd4991b24e16be523f.png" alt="\Im(x)" />. Unlike <tt class="docutils literal"><span class="pre">x.imag</span></tt>,
<tt class="xref docutils literal"><span class="pre">im()</span></tt> converts <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> to a mpmath number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;4.0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.conj">
<!--[mpmath.functions.conj]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">conj</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex conjugate of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/cd9d9d7da773d694be33df9af513af204628e732.png" alt="\overline{x}" />. Unlike
<tt class="docutils literal"><span class="pre">x.conjugate()</span></tt>, <tt class="xref docutils literal"><span class="pre">im()</span></tt> converts <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> to a mpmath number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpc(real=&#39;-1.0&#39;, imag=&#39;-4.0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.floor">
<!--[mpmath.functions.floor]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">floor</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the floor of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/06681f5b345750104366c512078960fee8d81b49.png" alt="\lfloor x \rfloor" />, defined as
the largest integer less than or equal to <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">floor</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
<span class="go">3.0</span>
</pre></div>
</div>
<p>Note: <tt class="xref docutils literal"><span class="pre">floor()</span></tt> returns a floating-point number, not a
Python <tt class="docutils literal"><span class="pre">int</span></tt>. If <img src="_images/math/06681f5b345750104366c512078960fee8d81b49.png" alt="\lfloor x \rfloor" /> is too large to be
represented exactly at the present working precision, the
result will be rounded, not necessarily in the floor
direction.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ceil">
<!--[mpmath.functions.ceil]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ceil</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ceiling of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/1a7cd7095a9b123f81967d8d3b14d1e02b0174e7.png" alt="\lceil x \rceil" />, defined as
the smallest integer greater than or equal to <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ceil</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>Note: <tt class="xref docutils literal"><span class="pre">ceil()</span></tt> returns a floating-point number, not a
Python <tt class="docutils literal"><span class="pre">int</span></tt>. If <img src="_images/math/1a7cd7095a9b123f81967d8d3b14d1e02b0174e7.png" alt="\lceil x \rceil" /> is too large to be
represented exactly at the present working precision, the
result will be rounded, not necessarily in the ceiling
direction.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.arg">
<!--[mpmath.functions.arg]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">arg</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the complex argument (phase) of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, defined as the
signed angle between the positive real axis and <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> in the
complex plane:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arg</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arg</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span>
<span class="go">0.785398163397448</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arg</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.5707963267949</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arg</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arg</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span>
<span class="go">-1.5707963267949</span>
</pre></div>
</div>
<p>The angle is defined to satisfy <img src="_images/math/fcfcb71dcf9ed5528f180f5f0f0b3a6033da1422.png" alt="-\pi &lt; \arg(x) \le \pi" /> and
with the sign convention that a nonnegative imaginary part
results in a nonnegative argument.</p>
<p>The value returned by <tt class="xref docutils literal"><span class="pre">arg()</span></tt> is an <tt class="docutils literal"><span class="pre">mpf</span></tt> instance.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.modf">
<!--[mpmath.functions.modf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">modf</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.modf" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> and <img src="_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y" /> to mpmath numbers and returns <img src="_images/math/f80dc582d3b3e35e603316ca7eab750b13579d0c.png" alt="x \mod y" />.
For mpmath numbers, this is equivalent to <tt class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">modf</span><span class="p">(</span><span class="mf">100</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="go">2.61062773871641</span>
</pre></div>
</div>
<p>You can use <tt class="xref docutils literal"><span class="pre">modf()</span></tt> to compute fractional parts of numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">modf</span><span class="p">(</span><span class="mf">10.25</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ldexp">
<!--[mpmath.functions.ldexp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ldexp</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.ldexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <img src="_images/math/97a885de4ed6de4d7aa8f6c4a5baa9c7cefbe640.png" alt="x 2^n" /> efficiently. No rounding is performed.
The argument <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> must be a real floating-point number (or
possible to convert into one) and <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> must be a Python <tt class="docutils literal"><span class="pre">int</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ldexp</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="go">mpf(&#39;1024.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ldexp</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;0.125&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.frexp">
<!--[mpmath.functions.frexp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">frexp</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.frexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a real number <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, returns <img src="_images/math/3e1c2368f88933a1a0062bce03e695ac95ad41bc.png" alt="(y, n)" /> with <img src="_images/math/27b4664469f28fe9f4c30bd8aaad9354aa66e354.png" alt="y \in [0.5, 1)" />,
<img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> a Python integer, and such that <img src="_images/math/6bf0d8bf86a6fd9fbcb5829e704d559564903d77.png" alt="x = y 2^n" />. No rounding is
performed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frexp</span><span class="p">(</span><span class="mf">7.5</span><span class="p">)</span>
<span class="go">(mpf(&#39;0.9375&#39;), 3)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="powers-and-logarithms">
<h2><a class="toc-backref" href="#id4">Powers and logarithms<a class="headerlink" href="#powers-and-logarithms" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.sqrt">
<!--[mpmath.functions.sqrt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sqrt</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">sqrt(x)</span></tt> computes the principal square root of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/4aa027abf288d84604eb02f64f3b9485aa648ed7.png" alt="\sqrt x" />.
For positive real numbers, the principal root is simply the
positive square root. For arbitrary complex numbers, the principal
square root is defined to satisfy <img src="_images/math/c029e0366a469e4e92b174d25c5c98bec0c787e6.png" alt="\sqrt x = \exp(\log(x)/2)" />.
The function thus has a branch cut along the negative half real axis.</p>
<p>For all mpmath numbers <tt class="docutils literal"><span class="pre">x</span></tt>, calling <tt class="docutils literal"><span class="pre">sqrt(x)</span></tt> is equivalent to
performing <tt class="docutils literal"><span class="pre">x**0.5</span></tt>.</p>
<p><strong>Examples</strong></p>
<p>Basic examples and limits:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">3.16227766016838</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">4</span><span class="p">)</span>
<span class="go">(0.0 + 2.0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1.09868411346781 + 0.455089860562227j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
</div>
<p>Square root evaluation is fast at huge precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;9329332814&#39;</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">sqrt()</span></tt> supports interval arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">16</span><span class="p">,</span> <span class="mf">100</span><span class="p">))</span>
<span class="go">[4.0, 10.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span>
<span class="go">[1.4142135623730949234, 1.4142135623730951455]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2</span>
<span class="go">[1.9999999999999995559, 2.0000000000000004441]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cbrt">
<!--[mpmath.functions.cbrt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cbrt</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cbrt" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">cbrt(x)</span></tt> computes the cube root of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/211fe368f21e7e87a497012b64962b2dae135c3d.png" alt="x^{1/3}" />. This
function is faster and more accurate than raising to a floating-point
fraction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">125</span><span class="o">**</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;4.9999999999999991&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cbrt</span><span class="p">(</span><span class="mf">125</span><span class="p">)</span>
<span class="go">mpf(&#39;5.0&#39;)</span>
</pre></div>
</div>
<p>Every nonzero complex number has three cube roots. This function
returns the cube root defined by <img src="_images/math/595023734d9ab251444ec4facc4d0b56b2d169cd.png" alt="\exp(\log(x)/3)" /> where the
principal branch of the natural logarithm is used. Note that this
does not give a real cube root for negative real numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cbrt</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">(0.5 + 0.866025403784439j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.nthroot">
<!--[mpmath.functions.nthroot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">nthroot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.nthroot" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">nthroot(x,</span> <span class="pre">n)</span></tt> computes the principal <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th root of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />,
<img src="_images/math/150f22361f31a17a5319a3984b1708b9978fec12.png" alt="x^{1/n}" />. Here <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> must be an integer, and can be negative
(<img src="_images/math/43577a4bb6fed57fefa828236669f403761e5ecc.png" alt="x^{-1/n}" /> is <img src="_images/math/6a9b9a4c4eae23d6ade48ceb41e518b1ad02e63f.png" alt="1/x^{1/n}" />).</p>
<p>For <img src="_images/math/598a16d4b7dde3dec3a390109882d54bb0308ea5.png" alt="n = 2" /> or <img src="_images/math/8c342b01f0cdef0f23d11a2bc9c5aa67f6d83ccb.png" alt="n = 3" />, using this function is equivalent to
calling <tt class="xref docutils literal"><span class="pre">sqrt()</span></tt> or <tt class="xref docutils literal"><span class="pre">cbrt()</span></tt>. In general,
<tt class="docutils literal"><span class="pre">nthroot(x,</span> <span class="pre">n)</span></tt> is defined to compute <img src="_images/math/d6baffc3886d98921b6cea85497fa832a78f6759.png" alt="\exp(\log(x)/n)" />.</p>
<p><tt class="xref docutils literal"><span class="pre">nthroot()</span></tt> is implemented to use Newton&#8217;s method for small
<img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />. At high precision, this makes <img src="_images/math/150f22361f31a17a5319a3984b1708b9978fec12.png" alt="x^{1/n}" /> not much more
expensive than the regular exponentiation, <img src="_images/math/8c72f3acf1f7744cfe76edaf47e45d62432cf28b.png" alt="x^n" />. For very large
<img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, <tt class="xref docutils literal"><span class="pre">nthroot()</span></tt> falls back to use the exponential function.</p>
<p><tt class="xref docutils literal"><span class="pre">nthroot()</span></tt> is faster and more accurate than raising to a
floating-point fraction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">16807</span> <span class="o">**</span> <span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">5</span><span class="p">)</span>
<span class="go">mpf(&#39;7.0000000000000009&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nthroot</span><span class="p">(</span><span class="mf">16807</span><span class="p">,</span> <span class="mf">5</span><span class="p">)</span>
<span class="go">mpf(&#39;7.0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hypot">
<!--[mpmath.functions.hypot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hypot</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.hypot" title="Permalink to this definition">¶</a></dt>
<dd>Computes the Euclidean norm of the vector <img src="_images/math/adfd9ae8a3fac031d3b8b470a52a709a23d4d6d2.png" alt="(x, y)" />, equal
to <img src="_images/math/c0688227c7a4c52edfc3dfbb79cf828c9e555c94.png" alt="\sqrt{x^2 + y^2}" />. Both <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> and <img src="_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y" /> must be real.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.exp">
<!--[mpmath.functions.exp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">exp</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.exp" title="Permalink to this definition">¶</a></dt>
<dd>Returns the exponential function of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ln">
<!--[mpmath.functions.ln]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ln</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ln" title="Permalink to this definition">¶</a></dt>
<dd>Computes the natural logarithm of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/30ce9b86d76868e8ba156e7a5efab18bff2f6e7c.png" alt="\ln x" />.
See <tt class="xref docutils literal"><span class="pre">log()</span></tt> for additional documentation.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.log">
<!--[mpmath.functions.log]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">log</tt><big>(</big><em>x</em>, <em>b=None</em><big>)</big><a class="headerlink" href="#mpmath.functions.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the base-<img src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" /> logarithm of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/7d77c6dd8aa838083121ba5452c6a3d65b9388ae.png" alt="\log_b(x)" />. If <img src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" /> is
unspecified, <tt class="xref docutils literal"><span class="pre">log()</span></tt> computes the natural (base <img src="_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" />) logarithm
and is equivalent to <tt class="xref docutils literal"><span class="pre">ln()</span></tt>. In general, the base <img src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" /> logarithm
is defined in terms of the natural logarithm as
<img src="_images/math/15cd1efc4e2252c7a722d2a13386b43ce6ecfa10.png" alt="\log_b(x) = \ln(x)/\ln(b)" />.</p>
<p>By convention, we take <img src="_images/math/831e4536400418726f42c728d469c9ac9457c65e.png" alt="\log(0) = -\infty" />.</p>
<p>The natural logarithm is real if <img src="_images/math/cae4fd68f44ac9b909f8d91f9d498de5759bb45b.png" alt="x &gt; 0" /> and complex if <img src="_images/math/36a68e8aa6ec6f48231ad80a4851f84bacf641b3.png" alt="x &lt; 0" /> or if
<img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> is complex. The principal branch of the complex logarithm is
used, meaning that <img src="_images/math/e56f17c32f52ac3c0c98c0a4ac5a4efbd4087987.png" alt="\Im(\ln(x)) = -\pi &lt; \arg(x) \le \pi" />.</p>
<p><strong>Examples</strong></p>
<p>Some basic values and limits:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.693147180559945</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span><span class="mf">10</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="mf">16</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.0 + 1.5707963267949j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">(0.0 + 3.14159265358979j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
</div>
<p>The natural logarithm is the antiderivative of <img src="_images/math/d172d3d8333a9c1740b123ea13d5b44f22446869.png" alt="1/x" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">5</span><span class="p">])</span>
<span class="go">1.6094379124341</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
<span class="go">1.6094379124341</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="go">0.1</span>
</pre></div>
</div>
<p>The Taylor series expansion of the natural logarithm around
<img src="_images/math/34310f2f36ed6d724838edb08788ee62acb33386.png" alt="x = 1" /> has coefficients <img src="_images/math/b8d4b1feff73224a9c61996d83573e0fdc6ab673.png" alt="(-1)^{n+1}/n" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">taylor</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">7</span><span class="p">))</span>
<span class="go">[0.0, 1.0, -0.5, 0.333333, -0.25, 0.2, -0.166667, 0.142857]</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">log()</span></tt> supports arbitrary precision evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.1447298858494001741434273513530587116472948129153</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="o">**</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.33333333333333333333333333333333333333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1.609437912434100374600759 + 0.9272952180016122324285125j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.log10">
<!--[mpmath.functions.log10]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">log10</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.log10" title="Permalink to this definition">¶</a></dt>
<dd>Computes the base-10 logarithm of <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/c179b3d2cf0aedab4cf71b933222a1ad8ae14ad4.png" alt="\log_{10}(x)" />. <tt class="docutils literal"><span class="pre">log10(x)</span></tt>
is equivalent to <tt class="docutils literal"><span class="pre">log(x,</span> <span class="pre">10)</span></tt>.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.power">
<!--[mpmath.functions.power]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">power</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> and <img src="_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y" /> to mpmath numbers and evaluates
<img src="_images/math/4c4a6df8d2bc2bfb583c11bc20504938026f6aa8.png" alt="x^y = \exp(y \log(x))" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">power</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">1.41421356237309504880168872421</span>
</pre></div>
</div>
<p>This shows the leading few digits of a large Mersenne prime
(performing the exact calculation <tt class="docutils literal"><span class="pre">2**43112609-1</span></tt> and
displaying the result in Python would be very slow):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">power</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="mf">43112609</span><span class="p">)</span><span class="o">-</span><span class="mf">1</span>
<span class="go">3.16470269330255923143453723949e+12978188</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fibonacci">
<!--[mpmath.functions.fibonacci]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fibonacci</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fibonacci" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">fibonacci(n)</span></tt> computes the <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th Fibonacci number, <img src="_images/math/2663041fd2b9fbd85c85ad832f67c7a743a09c52.png" alt="F(n)" />. The
Fibonacci numbers are defined by the recurrence <img src="_images/math/3c80df4dced24d2e083ecaf5eba04730e2abd010.png" alt="F(n) = F(n-1) + F(n-2)" />
with the initial values <img src="_images/math/e1676ed7f6f03f442bbb3620cc13f1d86a018db0.png" alt="F(0) = 0" />, <img src="_images/math/0faeea7ef7f0f0e89604b913937e23bd424c7035.png" alt="F(1) = 1" />. <tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt>
extends this definition to arbitrary real and complex arguments
using the formula</p>
<div class="math">
<p><img src="_images/math/bf1d4599e53249947baa0f7b49dd66f187d02ac2.png" alt="F(z) = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt 5}" />
</div></p><p>where <img src="_images/math/2c175f60eecef1de7560c3bdea495d69f26f719d.png" alt="\phi" /> is the golden ratio. <tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt> also uses this
continuous formula to compute <img src="_images/math/2663041fd2b9fbd85c85ad832f67c7a743a09c52.png" alt="F(n)" /> for extremely large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, where
calculating the exact integer would be wasteful.</p>
<p>For convenience, <tt class="xref docutils literal"><span class="pre">fib()</span></tt> is available as an alias for
<tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt>.</p>
<p><strong>Basic examples</strong></p>
<p>Some small Fibonacci numbers are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">0.0 1.0 1.0 2.0 3.0 5.0 8.0 13.0 21.0 34.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">50</span><span class="p">)</span>
<span class="go">12586269025.0</span>
</pre></div>
</div>
<p>The recurrence for <img src="_images/math/2663041fd2b9fbd85c85ad832f67c7a743a09c52.png" alt="F(n)" /> extends backwards to negative <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">0.0 1.0 -1.0 2.0 -3.0 5.0 -8.0 13.0 -21.0 34.0</span>
</pre></div>
</div>
<p>Large Fibonacci numbers will be computed approximately unless
the precision is set high enough:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">200</span><span class="p">)</span>
<span class="go">2.8057117299251e+41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">200</span><span class="p">)</span>
<span class="go">280571172992510140037611932413038677189525.0</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt> can compute approximate Fibonacci numbers
of stupendous size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">25</span><span class="p">)</span>
<span class="go">3.49052338550226e+2089876402499787337692720</span>
</pre></div>
</div>
<p><strong>Real and complex arguments</strong></p>
<p>The extended Fibonacci function is an analytic function. The
property <img src="_images/math/955ea4f7586d40c1fc76f92e7d448a88fc5b3eff.png" alt="F(z) = F(z-1) + F(z-2)" /> holds for arbitrary <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">2.1170270579161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">2.1170270579161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5248.51130728372 - 14195.962288353j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5248.51130728372 - 14195.962288353j)</span>
</pre></div>
</div>
<p>The Fibonacci function has infinitely many roots on the
negative half-real axis. The first root is at 0, the second is
close to -0.18, and then there are infinitely many roots that
asymptotically approach <img src="_images/math/7894a934b6faeaabe216e25c212c048c59c74aa7.png" alt="-n+1/2" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
<span class="go">-0.183802359692956</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-1.57077646820395</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">17</span><span class="p">)</span>
<span class="go">-16.4999999596115</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">24</span><span class="p">)</span>
<span class="go">-23.5000000000479</span>
</pre></div>
</div>
<p><strong>Mathematical relationships</strong></p>
<p>For large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, <img src="_images/math/faca141ea81723e491a81891dda2e718140eaa17.png" alt="F(n+1)/F(n)" /> approaches the golden ratio:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">101</span><span class="p">)</span><span class="o">/</span><span class="n">fibonacci</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">1.6180339887498948482045868343656381177203127439638</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span>
<span class="go">1.6180339887498948482045868343656381177203091798058</span>
</pre></div>
</div>
<p>The sum of reciprocal Fibonacci numbers converges to an irrational
number for which no closed form expression is known:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">3.35988566624318</span>
</pre></div>
</div>
<p>Amazingly, however, the sum of odd-index reciprocal Fibonacci
numbers can be expressed in terms of a Jacobi theta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.82451515740692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="o">*</span><span class="n">jtheta</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">,(</span><span class="mf">3</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">5</span><span class="p">))</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="o">/</span><span class="mf">4</span>
<span class="go">1.82451515740692</span>
</pre></div>
</div>
<p>Some related sums can be done in closed form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">)),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.11803398874989</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="go">1.11803398874989</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.618033988749895</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span><span class="o">-</span><span class="mf">1</span>
<span class="go">0.618033988749895</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/FibonacciNumber.html">http://mathworld.wolfram.com/FibonacciNumber.html</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.lambertw">
<!--[mpmath.functions.lambertw]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">lambertw</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.lambertw" title="Permalink to this definition">¶</a></dt>
<dd><p>The Lambert W function <img src="_images/math/d9f092163480eadf6f5084b9223116e5ee02f709.png" alt="W(z)" /> is defined as the inverse function
of <img src="_images/math/4f14b8f56034ac47a737c7a68d61849c9468570f.png" alt="w \exp(w)" />. In other words, the value of <img src="_images/math/d9f092163480eadf6f5084b9223116e5ee02f709.png" alt="W(z)" /> is such that
<img src="_images/math/453b5e9b62a3f5ffa964b35fe3d393cfcd78c6c0.png" alt="z = W(z) \exp(W(z))" /> for any complex number <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" />.</p>
<p>The Lambert W function is a multivalued function with infinitely
many branches. Each branch gives a separate solution of the
equation <img src="_images/math/4f14b8f56034ac47a737c7a68d61849c9468570f.png" alt="w \exp(w)" />. All branches are supported by
<tt class="xref docutils literal"><span class="pre">lambertw()</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">lambertw(z)</span></tt> gives the principal solution (branch 0)</li>
<li><tt class="docutils literal"><span class="pre">lambertw(z,</span> <span class="pre">k)</span></tt> gives the solution on branch <img src="_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" /></li>
</ul>
<p>The Lambert W function has two partially real branches: the
principal branch (<img src="_images/math/84574de7797bc7b4e1fc52075f4d265ba60a8bce.png" alt="k = 0" />) is real for real <img src="_images/math/371d182c625a220a79513c1dcaef4adba922738f.png" alt="z &gt; -1/e" />, and the
<img src="_images/math/a82f7b76d2e16054f75df1ea45cb2a043f09ffad.png" alt="k = -1" /> branch is real for <img src="_images/math/638a0971d2f3dc23d1dcb42c54cfa5b3daa4376c.png" alt="-1/e &lt; z &lt; 0" />. All branches except
<img src="_images/math/84574de7797bc7b4e1fc52075f4d265ba60a8bce.png" alt="k = 0" /> have a logarithmic singularity at <img src="_images/math/aa9f0d97d2f39f78f05e05da40bf04f5a7c0726c.png" alt="z = 0" />.</p>
<p><strong>Basic examples</strong></p>
<p>The Lambert W equation is the inverse of <img src="_images/math/4f14b8f56034ac47a737c7a68d61849c9468570f.png" alt="w \exp(w)" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span>
<span class="go">0.56714329040978387299996866221035555</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Any branch gives a valid inverse:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span>    <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">(-2.8535817554090378072068187234910812 + </span>
<span class="go">  17.113535539412145912607826671159289j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">(1.0 + 3.5075477124212226194278700785075126e-36j)</span>
</pre></div>
</div>
<p><strong>Applications to equation-solving</strong></p>
<p>The Lambert W function can give the value of the infinite power
tower <img src="_images/math/addf38dabe925cedd5b0dd1ec0f4ebf76bc4970f.png" alt="z^{z^{z^{\ldots}}}" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">tower</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">z</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">z</span> <span class="o">**</span> <span class="n">tower</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tower</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">100</span><span class="p">)</span>
<span class="go">0.641185744504986</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.6411857445049859844862004821148236665628209571911</span>
</pre></div>
</div>
<p><strong>Properties</strong></p>
<p>The Lambert W function grows roughly like the natural logarithm
for large arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">5.2496028524016</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">6.90775527898214</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">224.843106445119</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">230.258509299405</span>
</pre></div>
</div>
<p>The principal branch of the Lambert W function has a rational
Taylor series expansion around <img src="_images/math/aa9f0d97d2f39f78f05e05da40bf04f5a7c0726c.png" alt="z = 0" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">taylor</span><span class="p">(</span><span class="n">lambertw</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">6</span><span class="p">),</span> <span class="mf">10</span><span class="p">)</span>
<span class="go">[0.0, 1.0, -1.0, 1.5, -2.666666667, 5.208333333, -10.8]</span>
</pre></div>
</div>
<p>Some special values and limits are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.567143290409784</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
</div>
<p>The <img src="_images/math/84574de7797bc7b4e1fc52075f4d265ba60a8bce.png" alt="k = 0" /> and <img src="_images/math/a82f7b76d2e16054f75df1ea45cb2a043f09ffad.png" alt="k = -1" /> branches join at <img src="_images/math/b87eeae0e16a9f455c33ea11b80738764425b62d.png" alt="z = -1/e" /> where
<img src="_images/math/c8f915f0cf1bd473190da32d8ffebe485b7761ae.png" alt="W(z) = -1" /> for both branches. Since <img src="_images/math/57f1ee23691a5f2ed1e11109820ee928ceaeef65.png" alt="-1/e" /> can only be represented
approximately with mpmath numbers, evaluating the Lambert W function
at this point only gives <img src="_images/math/bae5aba07d37ff6ff813107e76260fb31ad5794e.png" alt="-1" /> approximately:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">-0.999999999999837133022867</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-1.00000000000016286697718</span>
</pre></div>
</div>
<p>If <img src="_images/math/57f1ee23691a5f2ed1e11109820ee928ceaeef65.png" alt="-1/e" /> happens to round in the negative direction, there might be
a small imaginary part:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">)</span>
<span class="go">(-1.0 + 8.22007971511612e-9j)</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p>The evaluation can become inaccurate very close to the branch point
at <img src="_images/math/57f1ee23691a5f2ed1e11109820ee928ceaeef65.png" alt="-1/e" />. In some corner cases, <tt class="xref docutils literal"><span class="pre">lambertw()</span></tt> might currently
fail to converge, or can end up on the wrong branch.</p>
<p><strong>Algorithm</strong></p>
<p>Halley&#8217;s iteration is used to invert <img src="_images/math/4f14b8f56034ac47a737c7a68d61849c9468570f.png" alt="w \exp(w)" />, using a first-order
asymptotic approximation (<img src="_images/math/ccca6529a839f6e1a7fb9817199765fbb6deabf4.png" alt="O(\log(w))" /> or <img src="_images/math/4631f2d763a4acbfccb2f2aa2f91f4be9850958c.png" alt="O(w)" />) as the initial
estimate.</p>
<p>The definition, implementation and choice of branches is based
on Corless et al, &#8220;On the Lambert W function&#8221;, Adv. Comp. Math. 5
(1996) 329-359, available online here:
<a class="reference external" href="http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf">http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf</a></p>
<p>TODO: use a series expansion when extremely close to the branch point
at <img src="_images/math/57f1ee23691a5f2ed1e11109820ee928ceaeef65.png" alt="-1/e" /> and make sure that the proper branch is chosen there</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-functions">
<h2><a class="toc-backref" href="#id5">Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.degrees">
<!--[mpmath.functions.degrees]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">degrees</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the radian angle <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> to a degree angle:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">degrees</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">3</span><span class="p">)</span>
<span class="go">60.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.radians">
<!--[mpmath.functions.radians]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">radians</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the degree angle <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> to radians:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">radians</span><span class="p">(</span><span class="mf">60</span><span class="p">)</span>
<span class="go">1.0471975511966</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cos">
<!--[mpmath.functions.cos]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cos</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cos" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sin">
<!--[mpmath.functions.sin]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sin</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sin" title="Permalink to this definition">¶</a></dt>
<dd>Returns the sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.tan">
<!--[mpmath.functions.tan]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">tan</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.tan" title="Permalink to this definition">¶</a></dt>
<dd>Returns the tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sec">
<!--[mpmath.functions.sec]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.sec" title="Permalink to this definition">¶</a></dt>
<dd>Returns the secant of x, 1/cos(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.csc">
<!--[mpmath.functions.csc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">csc</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.csc" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cosecant of x, 1/sin(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cot">
<!--[mpmath.functions.cot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cot</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.cot" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cotangent of x, 1/tan(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cospi">
<!--[mpmath.functions.cospi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cospi</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cospi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <img src="_images/math/d49c1e556b2fd2cb785ca3fe0d14d1247707b79a.png" alt="\cos(\pi x)" />, more accurately than the expression
<tt class="docutils literal"><span class="pre">cos(pi*x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cospi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">))</span>
<span class="go">1.0 0.999999999997493</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cospi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">0.0 1.59960492420134e-6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinpi">
<!--[mpmath.functions.sinpi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinpi</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <img src="_images/math/61395a5902d5ef1f78b3dc6e004e7856f9e45c71.png" alt="\sin(\pi x)" />, more accurately than the expression
<tt class="docutils literal"><span class="pre">sin(pi*x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinpi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">))</span>
<span class="go">0.0 -2.23936276195592e-6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinpi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">1.0 0.999999999998721</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinc">
<!--[mpmath.functions.sinc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinc</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">sinc(x)</span></tt> computes the unnormalized sinc function, defined as</p>
<div class="math">
<p><img src="_images/math/e7315df78c4286c99d922173f9185c3e050193a2.png" alt="\mathrm{sinc}(x) = \begin{cases}
    \sin(x)/x, &amp; \mbox{if } x \ne 0 \\
    1,         &amp; \mbox{if } x = 0.
\end{cases}" />
</div></p><p>See <tt class="xref docutils literal"><span class="pre">sincpi()</span></tt> for the normalized sinc function.</p>
<p>Simple values and limits include:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.841470984807897</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The integral of the sinc function is the sine integral Si:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">sinc</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.946083070367183</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">si</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.946083070367183</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sincpi">
<!--[mpmath.functions.sincpi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sincpi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sincpi" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">sincpi(x)</span></tt> computes the normalized sinc function, defined as</p>
<div class="math">
<p><img src="_images/math/32eb18f6e7c15d7073009f205d58061ccaae9e06.png" alt="\mathrm{sinc}_{\pi}(x) = \begin{cases}
    \sin(\pi x)/(\pi x), &amp; \mbox{if } x \ne 0 \\
    1,                   &amp; \mbox{if } x = 0.
\end{cases}" />
</div></p><p>Equivalently, we have
<img src="_images/math/2ef0be79204eb80d936b974993f0e84ec0c5d8e8.png" alt="\mathrm{sinc}_{\pi}(x) = \mathrm{sinc}(\pi x)" />.</p>
<p>The normalization entails that the function integrates
to unity over the entire real line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quadosc</span><span class="p">(</span><span class="n">sincpi</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Like, <tt class="xref docutils literal"><span class="pre">sinpi()</span></tt>, <tt class="xref docutils literal"><span class="pre">sincpi()</span></tt> is evaluated accurately
at its roots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sincpi</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acos">
<!--[mpmath.functions.acos]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acos</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.acos" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asin">
<!--[mpmath.functions.asin]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asin</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.asin" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atan">
<!--[mpmath.functions.atan]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atan</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.atan" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atan2">
<!--[mpmath.functions.atan2]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atan2</tt><big>(</big><em>y</em>, <em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.atan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the two-argument arctangent, <img src="_images/math/9dc6015dd5641eb929664202273a3d3f879f9e51.png" alt="\mathrm{atan2}(y, x)" />,
giving the signed angle between the positive <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />-axis and the
point <img src="_images/math/adfd9ae8a3fac031d3b8b470a52a709a23d4d6d2.png" alt="(x, y)" /> in the 2D plane. This function is defined for
real <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> and <img src="_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y" /> only.</p>
<p>The two-argument arctangent essentially computes
<img src="_images/math/8dad02890d0db27747cedab53775c0d00798e9ff.png" alt="\mathrm{atan}(y/x)" />, but accounts for the signs of both
<img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> and <img src="_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y" /> to give the angle for the correct quadrant. The
following examples illustrate the difference:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atan2</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">),</span> <span class="n">atan</span><span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.785398163397448 0.785398163397448</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atan2</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">),</span> <span class="n">atan</span><span class="p">(</span><span class="mf">1</span><span class="o">/-</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">2.35619449019234 -0.785398163397448</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">),</span> <span class="n">atan</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-0.785398163397448 -0.785398163397448</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">),</span> <span class="n">atan</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/-</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-2.35619449019234 0.785398163397448</span>
</pre></div>
</div>
<p>The angle convention is the same as that used for the complex
argument; see <tt class="xref docutils literal"><span class="pre">arg()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asec">
<!--[mpmath.functions.asec]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.asec" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse secant of x, acos(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acsc">
<!--[mpmath.functions.acsc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acsc</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acsc" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cosecant of x, asin(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acot">
<!--[mpmath.functions.acot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acot</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acot" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cotangent of x, atan(1/x)</dd></dl>

</div>
<div class="section" id="hyperbolic-functions">
<h2><a class="toc-backref" href="#id6">Hyperbolic functions<a class="headerlink" href="#hyperbolic-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.cosh">
<!--[mpmath.functions.cosh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cosh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cosh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinh">
<!--[mpmath.functions.sinh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.tanh">
<!--[mpmath.functions.tanh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">tanh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.tanh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sech">
<!--[mpmath.functions.sech]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sech</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.sech" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic secant of x, 1/cosh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.csch">
<!--[mpmath.functions.csch]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">csch</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.csch" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cosecant of x, 1/sinh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.coth">
<!--[mpmath.functions.coth]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">coth</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.coth" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cotangent of x, 1/tanh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acosh">
<!--[mpmath.functions.acosh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acosh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.acosh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asinh">
<!--[mpmath.functions.asinh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asinh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.asinh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atanh">
<!--[mpmath.functions.atanh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atanh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.atanh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asech">
<!--[mpmath.functions.asech]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asech</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.asech" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic secant of x, acosh(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acsch">
<!--[mpmath.functions.acsch]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acsch</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acsch" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cosecant of x, asinh(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acoth">
<!--[mpmath.functions.acoth]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acoth</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acoth" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cotangent of x, atanh(1/x)</dd></dl>

</div>
<div class="section" id="exponential-integrals">
<h2><a class="toc-backref" href="#id7">Exponential integrals<a class="headerlink" href="#exponential-integrals" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.erf">
<!--[mpmath.functions.erf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erf</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the error function, <img src="_images/math/24a55f83d76fde51296370fe18ea839a557f53b4.png" alt="\mathrm{erf}(x)" />. The error
function is the normalized antiderivative of the Gaussian function
<img src="_images/math/fb60aca3a6fcb6082e294c04c9cca57f49916065.png" alt="\exp(-t^2)" />. More precisely,</p>
<div class="math">
<p><img src="_images/math/ea21142041f1b312ff67d54e1b750820675ff290.png" alt="\mathrm{erf}(x) = \frac{2}{\sqrt \pi} \int_0^x \exp(-t^2) \,dt" />
</div></p><p><strong>Basic examples</strong></p>
<p>Simple values and limits include:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.842700792949715</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.842700792949715</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-1.0</span>
</pre></div>
</div>
<p>For large real <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, <img src="_images/math/24a55f83d76fde51296370fe18ea839a557f53b4.png" alt="\mathrm{erf}(x)" /> approaches 1 very
rapidly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.999977909503001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
<span class="go">0.999999999998463</span>
</pre></div>
</div>
<p>The error function is an odd function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">taylor</span><span class="p">(</span><span class="n">erf</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">5</span><span class="p">))</span>
<span class="go">[0.0, 1.12838, 0.0, -0.376126, 0.0, 0.112838]</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">erf()</span></tt> implements arbitrary-precision evaluation and
supports complex numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.52049987781304653768274665389196452873645157575796</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1.316151281697947644880271 + 0.1904534692378346862841089j)</span>
</pre></div>
</div>
<p><strong>Related functions</strong></p>
<p>See also <tt class="xref docutils literal"><span class="pre">erfc()</span></tt>, which is more accurate for large <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />,
and <tt class="xref docutils literal"><span class="pre">erfi()</span></tt> which gives the antiderivative of
<img src="_images/math/b133c76827decf65dd75b6f1a1a38dcf7c9476bf.png" alt="\exp(t^2)" />.</p>
<p>The Fresnel integrals <tt class="xref docutils literal"><span class="pre">fresnels()</span></tt> and <tt class="xref docutils literal"><span class="pre">fresnelc()</span></tt>
are also related to the error function.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfc">
<!--[mpmath.functions.erfc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfc</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the complementary error function,
<img src="_images/math/a8e29942bdfda249887cb34ecc6bdda95a1c7159.png" alt="\mathrm{erfc}(x) = 1-\mathrm{erf}(x)" />.
This function avoids cancellation that occurs when naively
computing the complementary error function as <tt class="docutils literal"><span class="pre">1-erf(x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">1</span> <span class="o">-</span> <span class="n">erf</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfc</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">2.08848758376254e-45</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">erfc()</span></tt> works accurately even for ludicrously large
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfc</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">)</span>
<span class="go">4.3504398860243e-43429448190325182776</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfi">
<!--[mpmath.functions.erfi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the imaginary error function, <img src="_images/math/a89580e826af5a48058d0bdf9f4312452fe8d889.png" alt="\mathrm{erfi}(x)" />.
The imaginary error function is defined in analogy with the
error function, but with a positive sign in the integrand:</p>
<div class="math">
<p><img src="_images/math/61318b2c70c69603e7e71d9cb72ea7235ecf7b1f.png" alt="\mathrm{erfi}(x) = \frac{2}{\sqrt \pi} \int_0^x \exp(t^2) \,dt" />
</div></p><p>Whereas the error function rapidly converges to 1 as <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> grows,
the imaginary error function rapidly diverges to infinity.
The functions are related as
<img src="_images/math/3018e8ed0c527e8a994940c6df66b75d9b9522e9.png" alt="\mathrm{erfi}(x) = -i\,\mathrm{erf}(ix)" /> for all complex
numbers <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />.</p>
<p><strong>Examples</strong></p>
<p>Basic values and limits:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">1.65042575879754</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-1.65042575879754</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p>Note the symmetry between erf and erfi:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.0 + 0.999977909503001j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.999977909503001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">2</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-0.536643565778565 - 5.04914370344703j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5.04914370344703 - 0.536643565778565j)</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p>The current implementation of <tt class="xref docutils literal"><span class="pre">erfi()</span></tt> is much less efficient
and accurate than the one for erf.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfinv">
<!--[mpmath.functions.erfinv]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfinv</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse error function, satisfying</p>
<div class="math">
<p><img src="_images/math/a7d28a51d8aa10dd203b36eded7a6b7707eba7d4.png" alt="\mathrm{erf}(\mathrm{erfinv}(x)) =
\mathrm{erfinv}(\mathrm{erf}(x)) = x." />
</div></p><p>This function is defined only for <img src="_images/math/f260c78fb4c935f83297e9c2cb2cf7c3c3e3adfc.png" alt="-1 \le x \le 1" />.</p>
<p><strong>Examples</strong></p>
<p>Special values include:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p>The domain is limited to the standard interval:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">erfinv</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">erfinv(x) is defined only for -1 &lt;= x &lt;= 1</span>
</pre></div>
</div>
<p>It is simple to check that <tt class="xref docutils literal"><span class="pre">erfinv()</span></tt> computes inverse values of
<tt class="xref docutils literal"><span class="pre">erf()</span></tt> as promised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">erfinv</span><span class="p">(</span><span class="mf">0.75</span><span class="p">))</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">erfinv</span><span class="p">(</span><span class="o">-</span><span class="mf">0.995</span><span class="p">))</span>
<span class="go">-0.995</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">erfinv()</span></tt> supports arbitrary-precision evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;0.99997790950300141455862722387041767962015229291260075&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erfinv</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
</pre></div>
</div>
<p>A definite integral involving the inverse error function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">erfinv</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.564189583547756</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.564189583547756</span>
</pre></div>
</div>
<p>The inverse error function can be used to generate random numbers
with a Gaussian distribution (although this is a relatively
inefficient algorithm):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="n">erfinv</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">rand</span><span class="p">()</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">6</span><span class="p">)])</span> <span class="c"># doctest: +SKIP</span>
<span class="go">[-0.586747, 1.10233, -0.376796, 0.926037, -0.708142, -0.732012]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.npdf">
<!--[mpmath.functions.npdf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">npdf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.npdf" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">npdf(x,</span> <span class="pre">mu=0,</span> <span class="pre">sigma=1)</span></tt> evaluates the probability density
function of a normal distribution with mean value <img src="_images/math/2d8c833ed800824727cd7bd2fb9de1a12ad7e674.png" alt="\mu" />
and variance <img src="_images/math/741fb9098efcb98055f467f87630a5d0ca599b6b.png" alt="\sigma^2" />.</p>
<p>Elementary properties of the probability distribution can
be verified using numerical integration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">npdf</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">npdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">3</span><span class="p">),</span> <span class="p">[</span><span class="mf">3</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">npdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">3</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>See also <tt class="xref docutils literal"><span class="pre">ncdf()</span></tt>, which gives the cumulative
distribution.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ncdf">
<!--[mpmath.functions.ncdf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ncdf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ncdf" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">ncdf(x,</span> <span class="pre">mu=0,</span> <span class="pre">sigma=1)</span></tt> evaluates the cumulative distribution
function of a normal distribution with mean value <img src="_images/math/6690e784718c1361117cfcd64ea7dbb49095d0d8.png" alt="mu" />
and variance <img src="_images/math/741fb9098efcb98055f467f87630a5d0ca599b6b.png" alt="\sigma^2" />.</p>
<p>See also <tt class="xref docutils literal"><span class="pre">npdf()</span></tt>, which gives the probability density.</p>
<p>Elementary properties include:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="o">+</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>The cumulative distribution is the integral of the density
function having identical mu and sigma:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="n">ncdf</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.053990966513188</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">npdf</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.053990966513188</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ncdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">0.107981933026376</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">npdf</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.107981933026376</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ei">
<!--[mpmath.functions.ei]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ei</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ei" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the exponential integral or Ei-function, <img src="_images/math/22547b8d0ed094d330ea27f6fb07e82a2bd29881.png" alt="\mathrm{Ei}(x)" />.
The exponential integral is defined as</p>
<div class="math">
<p><img src="_images/math/b6f50d1fcdf735206d82775af178e1e7db15f202.png" alt="\mathrm{Ei}(x) = \int_{-\infty\,}^x \frac{e^t}{t} \, dt." />
</div></p><p>When the integration range includes <img src="_images/math/288e2a39b58d673182c57dc6214b702a448341ea.png" alt="t = 0" />, the exponential
integral is interpreted as providing the Cauchy principal value.</p>
<p>For real <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />, the Ei-function behaves roughly like
<img src="_images/math/bfa32ad8fa62d527d51b3594a987c41477327f46.png" alt="\mathrm{Ei}(x) \approx \exp(x) + \log(|x|)" />.</p>
<p>This function should not be confused with the family of related
functions denoted by <img src="_images/math/0d3cbf9ab1e976e485e5a8b8459491ffa0b561dc.png" alt="E_n" /> which are also called &#8220;exponential
integrals&#8221;.</p>
<p><strong>Basic examples</strong></p>
<p>Some basic values and limits are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">1.89511781635594</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>For <img src="_images/math/36a68e8aa6ec6f48231ad80a4851f84bacf641b3.png" alt="x &lt; 0" />, the defining integral can be evaluated
numerically as a reference:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="o">-</span><span class="mf">4</span><span class="p">)</span>
<span class="go">-0.00377935240984891</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="mf">4</span><span class="p">])</span>
<span class="go">-0.00377935240984891</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">ei()</span></tt> supports complex arguments and arbitrary
precision evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">10.928374389331410348638445906907535171566338835056</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-4.154091651642689822535359 + 4.294418620024357476985535j)</span>
</pre></div>
</div>
<p><strong>Related functions</strong></p>
<p>The exponential integral is closely related to the logarithmic
integral. See <tt class="xref docutils literal"><span class="pre">li()</span></tt> for additional information.</p>
<p>The exponential integral is related to the hyperbolic
and trigonometric integrals (see <tt class="xref docutils literal"><span class="pre">chi()</span></tt>, <tt class="xref docutils literal"><span class="pre">shi()</span></tt>,
<tt class="xref docutils literal"><span class="pre">ci()</span></tt>, <tt class="xref docutils literal"><span class="pre">si()</span></tt>) similarly to how the ordinary
exponential function is related to the hyperbolic and
trigonometric functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">9.93383257062542</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">chi</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">shi</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">9.93383257062542</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ci</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span><span class="o">*</span><span class="n">si</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="mf">2</span>
<span class="go">(9.93383257062542 + 0.0j)</span>
</pre></div>
</div>
<p>Beware that logarithmic corrections, as in the last example
above, are required to obtain the correct branch in general.
For details, see [1].</p>
<p>The exponential integral is also a special case of the
hypergeometric function <img src="_images/math/1f6fb6dd6d16bd0ea3f9258e3b552ae516743eed.png" alt="\,_2F_2" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">z</span><span class="o">*</span><span class="n">hyper</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">],[</span><span class="mf">2</span><span class="p">,</span><span class="mf">2</span><span class="p">],</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="n">z</span><span class="p">))</span><span class="o">/</span><span class="mf">2</span> <span class="o">+</span> <span class="n">euler</span>
<span class="go">0.769881289937359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">0.769881289937359</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li>Relations between Ei and other functions:
<a class="reference external" href="http://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/27/01/">http://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/27/01/</a></li>
<li>Abramowitz &amp; Stegun, section 5:
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_228.htm">http://www.math.sfu.ca/~cbm/aands/page_228.htm</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.li">
<!--[mpmath.functions.li]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">li</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.li" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithmic integral or li-function
<img src="_images/math/0d6e907c00d0dad55d41518059061920eb2e90c8.png" alt="\mathrm{li}(x)" />, defined by</p>
<div class="math">
<p><img src="_images/math/f75ae63efadf7c64db115111b33de06ad147df96.png" alt="\mathrm{li}(x) = \int_0^x \frac{1}{\log t} \, dt" />
</div></p><p>The logarithmic integral has a singularity at <img src="_images/math/34310f2f36ed6d724838edb08788ee62acb33386.png" alt="x = 1" />.</p>
<p>Note that there is a second logarithmic integral, the Li
function, defined by</p>
<div class="math">
<p><img src="_images/math/f4e59528fc744218fa0a5ad2f680f5a6e9b8d4ad.png" alt="\mathrm{Li}(x) = \int_2^x \frac{1}{\log t} \, dt" />
</div></p><p>This &#8220;offset logarithmic integral&#8221; can be computed via
<tt class="xref docutils literal"><span class="pre">li()</span></tt> using the simple identity
<img src="_images/math/afd2720cc15b5e1df0fc0dbcdd26f48aa1cf6aca.png" alt="\mathrm{Li}(x) = \mathrm{li}(x) - \mathrm{li}(2)" />.</p>
<p><strong>Examples</strong></p>
<p>Some basic values and limits:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">1.04516378011749278484458888919</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">1.45136923488338105028396848589</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
</div>
<p>The logarithmic integral can be evaluated for arbitrary
complex arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(3.1343755504645775265 + 2.6769247817778742392j)</span>
</pre></div>
</div>
<p>The logarithmic integral is related to the exponential integral:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mf">3</span><span class="p">))</span>
<span class="go">2.1635885946671919729</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">2.1635885946671919729</span>
</pre></div>
</div>
<p>The logarithmic integral grows like <img src="_images/math/c43ced27cffc61a02cf7bdd2dc5761e7f1c3d379.png" alt="O(x/\log(x))" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">10</span><span class="o">**</span><span class="mf">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4.34294481903252e+97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4.3619719871407e+97</span>
</pre></div>
</div>
<p>The prime number theorem states that the number of primes less
than <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" /> is asymptotic to <img src="_images/math/0d6e907c00d0dad55d41518059061920eb2e90c8.png" alt="\mathrm{li}(x)" />. For example,
it is known that there are exactly 1,925,320,391,606,803,968,923
prime numbers less than 10^23 [1]. The logarithmic integral
provides a very accurate estimate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">li</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">23</span><span class="p">)</span>
<span class="go">1.92532039161405e+21</span>
</pre></div>
</div>
<p>A definite integral is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">-0.693147180559945</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-0.693147180559945</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/PrimeCountingFunction.html">http://mathworld.wolfram.com/PrimeCountingFunction.html</a></li>
<li><a class="reference external" href="http://mathworld.wolfram.com/LogarithmicIntegral.html">http://mathworld.wolfram.com/LogarithmicIntegral.html</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ci">
<!--[mpmath.functions.ci]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ci</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ci" title="Permalink to this definition">¶</a></dt>
<dd>Cosine integral, Ci(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.si">
<!--[mpmath.functions.si]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">si</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.si" title="Permalink to this definition">¶</a></dt>
<dd>Sine integral, Si(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chi">
<!--[mpmath.functions.chi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chi" title="Permalink to this definition">¶</a></dt>
<dd>Hyperbolic cosine integral, Chi(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.shi">
<!--[mpmath.functions.shi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">shi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.shi" title="Permalink to this definition">¶</a></dt>
<dd>Hyperbolic sine integral, Shi(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fresnels">
<!--[mpmath.functions.fresnels]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fresnels</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fresnels" title="Permalink to this definition">¶</a></dt>
<dd>Fresnel integral S, S(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fresnelc">
<!--[mpmath.functions.fresnelc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fresnelc</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fresnelc" title="Permalink to this definition">¶</a></dt>
<dd>Fresnel integral C, C(z)</dd></dl>

</div>
<div class="section" id="bessel-and-related-functions">
<h2><a class="toc-backref" href="#id8">Bessel and related functions<a class="headerlink" href="#bessel-and-related-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.jv">
<!--[mpmath.functions.jv]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">jv</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.jv" title="Permalink to this definition">¶</a></dt>
<dd>Bessel function J_v(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.airyai">
<!--[mpmath.functions.airyai]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">airyai</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.airyai" title="Permalink to this definition">¶</a></dt>
<dd>Airy function, Ai(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.airybi">
<!--[mpmath.functions.airybi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">airybi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.airybi" title="Permalink to this definition">¶</a></dt>
<dd>Airy function, Bi(z)</dd></dl>

</div>
<div class="section" id="gamma-and-related-functions">
<h2><a class="toc-backref" href="#id9">Gamma and related functions<a class="headerlink" href="#gamma-and-related-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.gamma">
<!--[mpmath.functions.gamma]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">gamma</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.gamma" title="Permalink to this definition">¶</a></dt>
<dd>Returns the gamma function of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.gammainc">
<!--[mpmath.functions.gammainc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">gammainc</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.gammainc" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">gammainc(z,</span> <span class="pre">a=0,</span> <span class="pre">b=inf)</span></tt> computes the (generalized) incomplete
gamma function with integration limits <img src="_images/math/da2e551d2ca2155b8d8f4935d2e9757722c9bab6.png" alt="[a, b]" />:</p>
<div class="math">
<p><img src="_images/math/1c35e8a24ac29184aa204a28b66fee318bab20dd.png" alt="\Gamma(z,a,b) = \int_a^b t^{z-1} e^{-t} \, dt" />
</div></p><p>The generalized incomplete gamma function reduces to the
following special cases when one or both endpoints are fixed:</p>
<ul class="simple">
<li><img src="_images/math/de26bc44efa7144cd4e6a60ee93f4e5f7c39d8e1.png" alt="\Gamma(z,0,\infty)" /> is the standard (&#8220;complete&#8221;)
gamma function, <img src="_images/math/f3bdf82eb6ddbd7c4870a75d6652ffbbb8f9224b.png" alt="\Gamma(z)" /> (available directly
as the mpmath function <tt class="xref docutils literal"><span class="pre">gamma()</span></tt>)</li>
<li><img src="_images/math/341baca0e80ef692894416999286ebd67b090b3b.png" alt="\Gamma(z,a,\infty)" /> is the &#8220;upper&#8221; incomplete gamma
function, <img src="_images/math/4f0145b57fff1fcb4af69a8f4a7af00e525b11d4.png" alt="\Gamma(z,a)" /></li>
<li><img src="_images/math/9ee8563ab8c1fe0852edb67920855aff8c2dd80b.png" alt="\Gamma(z,0,b)" /> is the &#8220;lower&#8221; incomplete gamma
function, <img src="_images/math/78d0784efd9748c0c726d80e96aa81c72a5419e6.png" alt="\gamma(z,b)" />.</li>
</ul>
<p>Of course, we have
<img src="_images/math/e19701f34ac72a2affda63599f878c7d8664b9cb.png" alt="\Gamma(z,0,x) + \Gamma(z,x,\infty) = \Gamma(z)" />
for all <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" /> and <img src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" />.</p>
<p>Note however that some authors reverse the order of the
arguments when defining the lower and upper incomplete
gamma function, so one should be careful to get the correct
definition.</p>
<p>If also given the keyword argument <tt class="docutils literal"><span class="pre">regularized=True</span></tt>,
<tt class="xref docutils literal"><span class="pre">gammainc()</span></tt> computes the &#8220;regularized&#8221; incomplete gamma
function</p>
<div class="math">
<p><img src="_images/math/4e50287e68f70409610b11ce66b425056b08cf2c.png" alt="P(z,a,b) = \frac{\Gamma(z,a,b)}{\Gamma(z)}." />
</div></p><p><strong>Examples</strong></p>
<p>We can compare with numerical quadrature to verify that
<tt class="xref docutils literal"><span class="pre">gammainc()</span></tt> computes the integral in the definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">3</span><span class="n">j</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="go">(0.009772126686277051606 - 0.077063730631298989245j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">**</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">3</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">),</span> <span class="p">[</span><span class="mf">4</span><span class="p">,</span> <span class="mf">10</span><span class="p">])</span>
<span class="go">(0.009772126686277051606 - 0.077063730631298989245j)</span>
</pre></div>
</div>
<p>The incomplete gamma functions satisfy simple recurrence
relations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mf">1</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">z</span><span class="o">*</span><span class="n">gammainc</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">**</span><span class="n">z</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
<span class="go">10.6013029693353 10.6013029693353</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> <span class="n">z</span><span class="o">*</span><span class="n">gammainc</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="n">z</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.03042542723211 1.03042542723211</span>
</pre></div>
</div>
<p>If <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" /> is an integer, the recurrence reduces the incomplete gamma
function to <img src="_images/math/f78411aea3227e4ea059cf9814f1cb899d74bdb3.png" alt="P(a) \exp(-a) + Q(b) \exp(-b)" /> where <img src="_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" /> and
<img src="_images/math/9866e3a998d628ba0941eb4fea0666ac391d149a.png" alt="Q" /> are polynomials:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.135335283236613 0.135335283236613</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">identify</span><span class="p">(</span><span class="n">gammainc</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="p">[</span><span class="s">&#39;exp(-1)&#39;</span><span class="p">,</span> <span class="s">&#39;exp(-2)&#39;</span><span class="p">])</span>
<span class="go">&#39;(326*exp(-1) + (-872)*exp(-2))&#39;</span>
</pre></div>
</div>
<p>The incomplete gamma functions reduce to functions such as
the exponential integral Ei and the error function for special
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">4</span><span class="p">),</span> <span class="o">-</span><span class="n">ei</span><span class="p">(</span><span class="o">-</span><span class="mf">4</span><span class="p">)</span>
<span class="go">0.00377935240984891 0.00377935240984891</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gammainc</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">erf</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span>
<span class="go">1.6918067329452 1.6918067329452</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.beta">
<!--[mpmath.functions.beta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">beta</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the beta function,
<img src="_images/math/d581222c803b0c037007450dad532ee5d2d87fea.png" alt="B(x,y) = \Gamma(x) \Gamma(y) / \Gamma(x+y)" />.
The beta function is also commonly defined by the integral
representation</p>
<div class="math">
<p><img src="_images/math/ea5243c07eaa244439559c98f772d752a72aeaad.png" alt="B(x,y) = \int_0^1 t^{x-1} (1-t)^{y-1} \, dt" />
</div></p><p><strong>Examples</strong></p>
<p>For integer and half-integer arguments where all three gamma
functions are finite, the beta function becomes either rational
number or a rational multiple of <img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">5</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.0333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.266666666666667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">16</span><span class="o">*</span><span class="n">beta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
</pre></div>
</div>
<p>Where appropriate, <tt class="xref docutils literal"><span class="pre">beta()</span></tt> evaluates limits. A pole
of the beta function is taken to result in <tt class="docutils literal"><span class="pre">+inf</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">-0.333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">beta()</span></tt> supports complex numbers and arbitrary precision
evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.4 - 0.2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">(1.079424249270925780135675 - 1.410032405664160838288752j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="go">0.037890298781212201348153837138927165984170287886464</span>
</pre></div>
</div>
<p>Various integrals can be computed by means of the
beta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">**</span><span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.0230880230880231</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">0.0230880230880231</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mf">4</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">])</span>
<span class="go">0.319504062596158</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span>
<span class="go">0.319504062596158</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.factorial">
<!--[mpmath.functions.factorial]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">factorial</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.factorial" title="Permalink to this definition">¶</a></dt>
<dd>Returns the factorial of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.binomial">
<!--[mpmath.functions.binomial]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">binomial</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#mpmath.functions.binomial" title="Permalink to this definition">¶</a></dt>
<dd>Binomial coefficient, C(n,k) = n!/(k!*(n-k)!).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.gammaprod">
<!--[mpmath.functions.gammaprod]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">gammaprod</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#mpmath.functions.gammaprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given iterables <img src="_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" /> and <img src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" />, <tt class="docutils literal"><span class="pre">gammaprod(a,</span> <span class="pre">b)</span></tt> computes the
product / quotient of gamma functions:</p>
<div class="math">
<p><img src="_images/math/ab622d03541d902f5282d1b80c21fc40ce599d6a.png" alt="\frac{\Gamma(a_0) \Gamma(a_1) \cdots \Gamma(a_p)}
     {\Gamma(b_0) \Gamma(b_1) \cdots \Gamma(b_q)}" />
</div></p><p><strong>Handling of poles</strong></p>
<p>Unlike direct calls to <tt class="xref docutils literal"><span class="pre">gamma()</span></tt>, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt> considers
the entire product as a limit and evaluates this limit properly if
any of the numerator or denominator arguments are nonpositive
integers such that poles of the gamma function are encountered.</p>
<p>In particular:</p>
<ul class="simple">
<li>If there are equally many poles in the numerator and the
denominator, the limit is a rational number times the remaining,
regular part of the product.</li>
<li>If there are more poles in the numerator, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt>
returns <tt class="docutils literal"><span class="pre">+inf</span></tt>.</li>
<li>If there are more poles in the denominator, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt>
returns 0.</li>
</ul>
<p><strong>Examples</strong></p>
<p>The reciprocal gamma function <img src="_images/math/88acd233f0e0f03bd54278e4a23d853d82f1df69.png" alt="1/\Gamma(x)" /> evaluated at <img src="_images/math/2d348bde3e15456e71734dc2c56fc7425c95927f.png" alt="x = 0" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gammaprod</span><span class="p">([],</span> <span class="p">[</span><span class="mf">0</span><span class="p">])</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
</pre></div>
</div>
<p>A limit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gammaprod</span><span class="p">([</span><span class="o">-</span><span class="mf">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">3</span><span class="p">])</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="n">direction</span><span class="o">=-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.rf">
<!--[mpmath.functions.rf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">rf</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.rf" title="Permalink to this definition">¶</a></dt>
<dd>Rising factorial (Pochhammer symbol), x^(n)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ff">
<!--[mpmath.functions.ff]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ff</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.ff" title="Permalink to this definition">¶</a></dt>
<dd>Falling factorial, x_(n)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.psi">
<!--[mpmath.functions.psi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">psi</tt><big>(</big><em>m</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the polygamma function of order m of z, psi^(m)(z). Special
cases are the digamma function (psi0), trigamma function (psi1),
tetragamma (psi2) and pentagamma (psi4) functions.</p>
<p>The parameter m should be a nonnegative integer.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.harmonic">
<!--[mpmath.functions.harmonic]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">harmonic</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>If <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> is an integer, <tt class="docutils literal"><span class="pre">harmonic(n)</span></tt> gives a floating-point
approximation of the <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th harmonic number <img src="_images/math/58a3a829660a9f4760582b6a696c712b9a464abe.png" alt="H(n)" />, defined as</p>
<div class="math">
<p><img src="_images/math/306186c8a1fd38b3f7ae411184a7538561fed918.png" alt="H(n) = 1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n}" />
</div></p><p>The firrst few harmonic numbers are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 0.0</span>
<span class="go">1 1.0</span>
<span class="go">2 1.5</span>
<span class="go">3 1.83333333333333</span>
<span class="go">4 2.08333333333333</span>
<span class="go">5 2.28333333333333</span>
<span class="go">6 2.45</span>
<span class="go">7 2.59285714285714</span>
</pre></div>
</div>
<p>The infinite harmonic series <img src="_images/math/291e353af0258dda7e14e507fad50acb1acc36d1.png" alt="1 + 1/2 + 1/3 + \ldots" /> diverges:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">harmonic()</span></tt> is evaluated using the digamma function rather
than by summing the harmonic series term by term. It can therefore
be computed quickly for arbitrarily large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, and even for
nonintegral arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">230.835724964306</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.613705638880109</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(2.24757548223494 + 0.850502209186044j)</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">harmonic()</span></tt> supports arbitrary precision evaluation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">11</span><span class="p">)</span>
<span class="go">3.0198773448773448773448773448773448773448773448773</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.8727388590273302654363491032336134987519132374152</span>
</pre></div>
</div>
<p>The harmonic series diverges, but at a glacial pace. It is possible
to calculate the exact number of terms required before the sum
exceeds a given amount, say 100:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="mf">10</span><span class="o">**</span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">100</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span>
<span class="go">15092688622113788323693563264538101449859496.864101</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span>
<span class="go">15092688622113788323693563264538101449859497</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">99.999999999999999999999999999999999999999999942747</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">100.000000000000000000000000000000000000000000009</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="riemann-zeta-function-bernoulli-numbers-and-related">
<h2><a class="toc-backref" href="#id10">Riemann zeta function, Bernoulli numbers and related<a class="headerlink" href="#riemann-zeta-function-bernoulli-numbers-and-related" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.zeta">
<!--[mpmath.functions.zeta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">zeta</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">zeta(s)</span></tt> computes the Riemann zeta function, <img src="_images/math/031cb95fe26028bb28c91f9ba046b40eca3bc5f1.png" alt="\zeta(s)" />.
The Riemann zeta function is defined for <img src="_images/math/0595aab81177f026be8c3d56c543764ac9d0fa1a.png" alt="\Re(s) &gt; 1" /> by</p>
<div class="math">
<p><img src="_images/math/7faaa2da7d5dc9d2a8db850829be0d184de64d4f.png" alt="\zeta(s) = 1+\frac{1}{2^s}+\frac{1}{3^s}+\frac{1}{4^s}+\ldots" />
</div></p><p>and for <img src="_images/math/4ba63cdac9537ac889e1f9d9b171063da1c526ee.png" alt="\Re(s) \le 1" /> by analytic continuation. It has a pole
at <img src="_images/math/231cd70adaea591bac095e7290c91c1e9d41d8a3.png" alt="s = 1" />.</p>
<p><strong>Examples</strong></p>
<p>Some exact values of the zeta function are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span><span class="o">**</span><span class="mf">2</span> <span class="o">/</span> <span class="mf">6</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">-0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0833333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">zeta()</span></tt> supports arbitrary precision evaluation and
complex arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.1762417383825827588721504519380520911697389900217</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">2</span><span class="n">j</span><span class="p">)</span>  <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">(0.5981655697623817367034568491742186771747764868876 -</span>
<span class="go">0.35185474521784529049653859679690026505229177886045j)</span>
</pre></div>
</div>
<p>The Riemann zeta function has so-called nontrivial zeros on
the critical line <img src="_images/math/a96b9c7b2fd49e0d6a36887684ff29da9de559b3.png" alt="s = 1/2 + it" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">14</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 14.1347251417347j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">21</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 21.0220396387716j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">25</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 25.0108575801457j)</span>
</pre></div>
</div>
<p>For large positive <img src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" />, <img src="_images/math/031cb95fe26028bb28c91f9ba046b40eca3bc5f1.png" alt="\zeta(s)" /> rapidly approaches 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">1.00000000093133</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>The following series converges and in fact has a simple
closed form value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">zeta</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="p">[</span><span class="mf">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p><strong>Algorithm</strong></p>
<p>The primary algorithm is Borwein&#8217;s algorithm for the Dirichlet
eta function. Three separate implementations are used: for general
real arguments, general complex arguments, and for integers. The
reflection formula is applied to arguments in the negative
half-plane. For very large real arguments, either direct
summation or the Euler prime product is used.</p>
<p>It should be noted that computation of <img src="_images/math/031cb95fe26028bb28c91f9ba046b40eca3bc5f1.png" alt="\zeta(s)" /> gets very slow
when <img src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" /> is far away from the real axis.</p>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/RiemannZetaFunction.html">http://mathworld.wolfram.com/RiemannZetaFunction.html</a></li>
<li><a class="reference external" href="http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf">http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.altzeta">
<!--[mpmath.functions.altzeta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">altzeta</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.altzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Dirichlet eta function, <img src="_images/math/0bc6f3bd7d91d9f60d7f8cf621067d999cc5068b.png" alt="\eta(s)" />, also known as the
alternating zeta function. This function is defined in analogy
with the Riemann zeta function as providing the sum of the
alternating series</p>
<div class="math">
<p><img src="_images/math/f38acf2790d80b27d3d7276cc54da2b91a1d3dc8.png" alt="\eta(s) = 1-\frac{1}{2^s}+\frac{1}{3^s}-\frac{1}{4^s}+\ldots" />
</div></p><p>Note that <img src="_images/math/5858d2e8c7357308e244b4cb97852a3625f9e813.png" alt="\eta(1) = \log(2)" /> is the alternating harmonic series.
The eta function unlike the Riemann zeta function is an entire
function, having a finite value for all complex <img src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" />.</p>
<p>The alternating and non-alternating zeta functions are related
via the simple formula</p>
<div class="math">
<p><img src="_images/math/068cfbfa716eced437e5e95df5e3327e327fb848.png" alt="\eta(s) = (1 - 2^{1-s}) \zeta(s)." />
</div></p><p>This formula can be used to define <img src="_images/math/0bc6f3bd7d91d9f60d7f8cf621067d999cc5068b.png" alt="\eta(s)" /> for <img src="_images/math/8479fb84311003962d1a57364bf901ae6c72b4b2.png" alt="\Re(s) \le 0" />,
where the series diverges.</p>
<p><strong>Examples</strong></p>
<p>Some special values are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.693147180559945</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>An example of a sum that can be computed more accurately and
efficiently via <tt class="xref docutils literal"><span class="pre">altzeta()</span></tt> than via numerical summation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mf">2.5</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">100</span><span class="p">))</span>
<span class="go">0.86720495150398402</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
<span class="go">0.867199889012184</span>
</pre></div>
</div>
<p>At positive even integers, the Dirichlet eta function
evaluates to a rational multiple of a power of <img src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.822467033424113</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span><span class="o">**</span><span class="mf">2</span><span class="o">/</span><span class="mf">12</span>
<span class="go">0.822467033424113</span>
</pre></div>
</div>
<p>Like the Riemann zeta function, <img src="_images/math/0bc6f3bd7d91d9f60d7f8cf621067d999cc5068b.png" alt="\eta(s)" />, approaches 1
as <img src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" /> approaches positive infinity, although it does
so from below rather than from above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">0.999999999068682</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;0.99999999999999989&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;1.0&#39;)</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/DirichletEtaFunction.html">http://mathworld.wolfram.com/DirichletEtaFunction.html</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Dirichlet_eta_function">http://en.wikipedia.org/wiki/Dirichlet_eta_function</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.bernoulli">
<!--[mpmath.functions.bernoulli]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">bernoulli</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the nth Bernoulli number, <img src="_images/math/9be2b1de79fff66db67de3b18303bdd2912b7ae6.png" alt="B_n" />, for any integer <img src="_images/math/e2c7d62172af0e738dd12f47f3f8ad8ef70cd65f.png" alt="n \ge 0" />.</p>
<p>The Bernoulli numbers are rational numbers, but this function
returns a floating-point approximation. To obtain an exact
fraction, use <tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> instead.</p>
<p><strong>Examples</strong></p>
<p>Numerical values of the first few Bernoulli numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">15</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="n">bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 1.0</span>
<span class="go">1 -0.5</span>
<span class="go">2 0.166666666666667</span>
<span class="go">3 0.0</span>
<span class="go">4 -0.0333333333333333</span>
<span class="go">5 0.0</span>
<span class="go">6 0.0238095238095238</span>
<span class="go">7 0.0</span>
<span class="go">8 -0.0333333333333333</span>
<span class="go">9 0.0</span>
<span class="go">10 0.0757575757575758</span>
<span class="go">11 0.0</span>
<span class="go">12 -0.253113553113553</span>
<span class="go">13 0.0</span>
<span class="go">14 1.16666666666667</span>
</pre></div>
</div>
<p>Bernoulli numbers can be approximated with arbitrary precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">-2.8382249570693706959264156336481764738284680928013e+78</span>
</pre></div>
</div>
<p>Arbitrarily large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> are supported:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">20</span> <span class="o">+</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">3.09136296657021e+1876752564973863312327</span>
</pre></div>
</div>
<p>The Bernoulli numbers are related to the Riemann zeta function
at integer arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">bernoulli</span><span class="p">(</span><span class="mf">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mf">8</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="mf">8</span><span class="p">))</span>
<span class="go">1.00407735619794</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">8</span><span class="p">)</span>
<span class="go">1.00407735619794</span>
</pre></div>
</div>
<p><strong>Algorithm</strong></p>
<p>For small <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> (<img src="_images/math/67569ba3ff78135cda24dd931ebb5817a602a571.png" alt="n &lt; 3000" />) <tt class="xref docutils literal"><span class="pre">bernoulli()</span></tt> uses a recurrence
formula due to Ramanujan. All results in this range are cached,
so sequential computation of small Bernoulli numbers is
guaranteed to be fast.</p>
<p>For larger <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, <img src="_images/math/9be2b1de79fff66db67de3b18303bdd2912b7ae6.png" alt="B_n" /> is evaluated in terms of the Riemann zeta
function.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.bernfrac">
<!--[mpmath.functions.bernfrac]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">bernfrac</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.bernfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of integers <img src="_images/math/e148d95e9a2349eff0d0ccd1ec50ace5fa25269b.png" alt="(p, q)" /> such that <img src="_images/math/ed0e40214b4c65391930d730e70ced3aac62cc97.png" alt="p/q = B_n" /> exactly,
where <img src="_images/math/9be2b1de79fff66db67de3b18303bdd2912b7ae6.png" alt="B_n" /> denotes the <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th Bernoulli number. The fraction is
always reduced to lowest terms. Note that for <img src="_images/math/49d98ffe996c0f0d3b82b284cba2113439fefea9.png" alt="n &gt; 1" /> and <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> odd,
<img src="_images/math/d72198ae318470c88b2114f13302cfcf4e9e9563.png" alt="B_n = 0" />, and <img src="_images/math/6457ca2dcd40dc21d9aa0db18c66bbac9af4d899.png" alt="(0, 1)" /> is returned.</p>
<p><strong>Examples</strong></p>
<p>The first few Bernoulli numbers are exactly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">15</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">bernfrac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 1/1</span>
<span class="go">1 -1/2</span>
<span class="go">2 1/6</span>
<span class="go">3 0/1</span>
<span class="go">4 -1/30</span>
<span class="go">5 0/1</span>
<span class="go">6 1/42</span>
<span class="go">7 0/1</span>
<span class="go">8 -1/30</span>
<span class="go">9 0/1</span>
<span class="go">10 5/66</span>
<span class="go">11 0/1</span>
<span class="go">12 -691/2730</span>
<span class="go">13 0/1</span>
<span class="go">14 7/6</span>
</pre></div>
</div>
<p>This function works for arbitrarily large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">bernfrac</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">q</span>
<span class="go">2338224387510</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">27692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mpf</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">q</span>
<span class="go">-9.04942396360948e+27677</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">4</span><span class="p">)</span>
<span class="go">-9.04942396360948e+27677</span>
</pre></div>
</div>
<p>Note: <tt class="xref docutils literal"><span class="pre">bernoulli()</span></tt> computes a floating-point approximation
directly, without computing the exact fraction first.
This is much faster for large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />.</p>
<p><strong>Algorithm</strong></p>
<p><tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> works by computing the value of <img src="_images/math/9be2b1de79fff66db67de3b18303bdd2912b7ae6.png" alt="B_n" /> numerically
and then using the von Staudt-Clausen theorem [1] to reconstruct
the exact fraction. For large <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, this is significantly faster than
computing <img src="_images/math/1cd96ae0505c9d2838694d3a5b0aa6d11399258a.png" alt="B_1, B_2, \ldots, B_2" /> recursively with exact arithmetic.
The implementation has been tested for <img src="_images/math/b68ef9ff01dd02bd64b149ecbb2066555a1df67e.png" alt="n = 10^m" /> up to <img src="_images/math/970c67d43e2cd7f3e62f1e9afeb5d18508c8dd34.png" alt="m = 6" />.</p>
<p>In practice, <tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> appears to be about three times
slower than the specialized program calcbn.exe [2]</p>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li>MathWorld, von Staudt-Clausen Theorem:
<a class="reference external" href="http://mathworld.wolfram.com/vonStaudt-ClausenTheorem.html">http://mathworld.wolfram.com/vonStaudt-ClausenTheorem.html</a></li>
<li>The Bernoulli Number Page:
<a class="reference external" href="http://www.bernoulli.org/">http://www.bernoulli.org/</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.stieltjes">
<!--[mpmath.functions.stieltjes]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">stieltjes</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.stieltjes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a nonnegative integer <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, <tt class="docutils literal"><span class="pre">stieltjes(n)</span></tt> computes the
<img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th Stieltjes constant <img src="_images/math/55f6b5380d462f954b65d7a2cd05e02ff8cc832e.png" alt="\gamma_n" />, defined as the
<img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />-th coefficient in the Laurent series expansion of the
Riemann zeta function around the pole at <img src="_images/math/231cd70adaea591bac095e7290c91c1e9d41d8a3.png" alt="s = 1" />. That is,
we have:</p>
<div class="math">
<p><img src="_images/math/5e54a4f7913e7906f73ed588cbff7eca0c4649f9.png" alt="\zeta(s) = \frac{1}{s-1} \sum_{n=0}^{\infty}
    \frac{(-1)^n}{n!} \gamma_n (s-1)^n" />
</div></p><p><strong>Examples</strong></p>
<p>The zeroth Stieltjes constant is just Euler&#8217;s constant <img src="_images/math/66981fa3920210c6ad8dbe5e968783d5dd7520c3.png" alt="\gamma" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.577215664901533</span>
</pre></div>
</div>
<p>Some more values are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0728158454836767</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.000205332814909065</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">0.00355772885557316</span>
</pre></div>
</div>
<p>An alternative way to compute <img src="_images/math/24746dfd17e9188871007307efc793c9be692647.png" alt="\gamma_1" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="n">extradps</span><span class="p">(</span><span class="mf">25</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0728158454836767</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">stieltjes()</span></tt> supports arbitrary precision evaluation,
and caches computed results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-0.0096903631928723184845303860352125293590658061013408</span>
</pre></div>
</div>
<p><strong>Algorithm</strong></p>
<p>The calculation is done using numerical differentiation
for very small <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> (currently <img src="_images/math/9dbca6c95f7d3b0cfa2174589fdf0f7d46d27235.png" alt="n = 1,2,3" />).</p>
<p>For larger <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" />, integration of the Riemann zeta function is
used. The method should work for any <img src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" /> and precision, but
soon becomes quite slow in practice. The code has been tested
with <img src="_images/math/3260de5e72fd6cdb211848fe2677cb671b301c98.png" alt="n = 50" /> and 100 digit precision; that computation took
about 2 minutes.</p>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/StieltjesConstants.html">http://mathworld.wolfram.com/StieltjesConstants.html</a></li>
<li><a class="reference external" href="http://pi.lacim.uqam.ca/piDATA/stieltjesgamma.txt">http://pi.lacim.uqam.ca/piDATA/stieltjesgamma.txt</a></li>
</ol>
</dd></dl>

</div>
<div class="section" id="hypergeometric-functions">
<h2><a class="toc-backref" href="#id11">Hypergeometric functions<a class="headerlink" href="#hypergeometric-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.hyper">
<!--[mpmath.functions.hyper]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyper</tt><big>(</big><em>a_s</em>, <em>b_s</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyper" title="Permalink to this definition">¶</a></dt>
<dd><p>Hypergeometric function pFq:</p>
<div class="highlight-python"><pre>    [ a_1, a_2, ..., a_p |    ]
pFq [                    |  z ]
    [ b_1, b_2, ..., b_q |    ]</pre>
</div>
<p>The parameter lists a_s and b_s may contain real or complex numbers.
Exact rational parameters can be given as tuples (p, q).</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp0f1">
<!--[mpmath.functions.hyp0f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp0f1</tt><big>(</big><em>a</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp0f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 0F1. hyp0f1(a,z) is equivalent
to hyper([], [a], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp1f1">
<!--[mpmath.functions.hyp1f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp1f1</tt><big>(</big><em>a</em>, <em>b</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp1f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 1F1. hyp1f1(a,b,z) is equivalent
to hyper([a], [b], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp2f1">
<!--[mpmath.functions.hyp2f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp2f1</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp2f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 2F1. hyp2f1(a,b,c,z) is equivalent
to hyper([a,b], [c], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.jacobi">
<!--[mpmath.functions.jacobi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">jacobi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.jacobi" title="Permalink to this definition">¶</a></dt>
<dd>Jacobi polynomial P_n^(a,b)(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.legendre">
<!--[mpmath.functions.legendre]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">legendre</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.legendre" title="Permalink to this definition">¶</a></dt>
<dd>Legendre polynomial P_n(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chebyt">
<!--[mpmath.functions.chebyt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chebyt</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chebyt" title="Permalink to this definition">¶</a></dt>
<dd>Chebyshev polynomial of the first kind T_n(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chebyu">
<!--[mpmath.functions.chebyu]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chebyu</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chebyu" title="Permalink to this definition">¶</a></dt>
<dd>Chebyshev polynomial of the second kind U_n(x).</dd></dl>

</div>
<div class="section" id="elliptic-functions">
<h2><a class="toc-backref" href="#id12">Elliptic functions<a class="headerlink" href="#elliptic-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.agm">
<!--[mpmath.functions.agm]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">agm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.agm" title="Permalink to this definition">¶</a></dt>
<dd><p>agm(a, b) computes the arithmetic-geometric mean of a and b,
defined as the limit of the iteration a, b = (a+b)/2, sqrt(a*b).</p>
<p>This function can be called with a single argument, computing
agm(a,1) = agm(1,a).</p>
<p><strong>Examples</strong></p>
<p>A formula for gamma(1/4):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gamma</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">3.62560990822191</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mf">3</span><span class="p">)</span><span class="o">/</span><span class="n">agm</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">)))</span>
<span class="go">3.62560990822191</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">agm()</span></tt> may not give an appropriate branch for complex
arguments a and b.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ellipe">
<!--[mpmath.functions.ellipe]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ellipe</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ellipe" title="Permalink to this definition">¶</a></dt>
<dd>Complete elliptic integral of the second kind, E(m). Note that
the argument is the parameter m = k^2, not the modulus k.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ellipk">
<!--[mpmath.functions.ellipk]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ellipk</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ellipk" title="Permalink to this definition">¶</a></dt>
<dd>Complete elliptic integral of the first kind, K(m). Note that
the argument is the parameter m = k^2, not the modulus k.</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jtheta">
<!--[mpmath.elliptic.jtheta]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jtheta</tt><big>(</big><em>n</em>, <em>z</em>, <em>q</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jtheta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jacobi theta function <img src="_images/math/c3cf9a7b93535d07185603a625973776a711146a.png" alt="\vartheta_n(z, q)" />, where
<img src="_images/math/2ccb96c3451d351085035d873b42734c582c37c6.png" alt="n = 1, 2, 3, 4" />. The theta functions are functions of two
variables:</p>
<ul class="simple">
<li><img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" /> is the <em>argument</em>, an arbitrary real or complex number</li>
<li><img src="_images/math/0615acc3725de21025457e7d6f7694dab8e2f758.png" alt="q" /> is the <em>nome</em>, which must be a real or complex number
in the unit disk (i.e. <img src="_images/math/1ac3bec0deb1b3d8164b2938edd7bb85d132b005.png" alt="|q| &lt; 1" />)</li>
</ul>
<p>One also commonly encounters the notation <img src="_images/math/7f80346c0a66bc91693a27639c24a978fda6aaf8.png" alt="\vartheta_n(z, \tau)" />
in the literature. The variable <img src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" /> is called the <em>parameter</em>
and can be converted to a nome using the formula
<img src="_images/math/a9e6f652e2d3b5ae86ac7120ab4b5868ec37efd7.png" alt="q = \exp(i \pi \tau)" />. Note the condition <img src="_images/math/1ac3bec0deb1b3d8164b2938edd7bb85d132b005.png" alt="|q| &lt; 1" /> requires
<img src="_images/math/033de4fe9bd4f4731fbab45fa896c1f65a50f7de.png" alt="\Im(\tau) &gt; 0" />; i.e. Jacobi theta functions are defined for
<img src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" /> in the upper half plane.</p>
<p>Other notations are also in use. For example, some authors use
the single-argument form <img src="_images/math/824dca2fa320bae0792d12fd5bd29be4797fdebd.png" alt="\vartheta_n(x)" />. Depending on context,
this can mean <tt class="docutils literal"><span class="pre">jtheta(n,</span> <span class="pre">0,</span> <span class="pre">x)</span></tt>, <tt class="docutils literal"><span class="pre">jtheta(n,</span> <span class="pre">x,</span> <span class="pre">q)</span></tt>, or possibly
something else. Needless to say, it is a good idea to cross-check
the definitions when working with theta functions.</p>
<p><strong>Definition</strong></p>
<p>The four Jacobi theta functions as implemented by <tt class="xref docutils literal"><span class="pre">jtheta()</span></tt>
are defined by the following infinite series:</p>
<div class="math">
<p><img src="_images/math/2c0835f2c4410406b2f132679e2d8afa779aaffd.png" alt="\vartheta_1(z,q) = 2 q^{1/4} \sum_{n=0}^{\infty}
  (-1)^n q^{n^2+n\,} \sin((2n+1)z)

\vartheta_2(z,q) = 2 q^{1/4} \sum_{n=0}^{\infty}
  q^{n^{2\,} + n} \cos((2n+1)z)

\vartheta_3(z,q) = 1 + 2 \sum_{n=0}^{\infty}
  q^{n^2\,} \cos(2 n z)

\vartheta_4(z,q) = 1 + 2 \sum_{n=0}^{\infty}
  (-q)^{n^2\,} \cos(2 n z)" />
</div></p><p>For <img src="_images/math/90857d9871b7c3fa3da5e460b4dcf28e15010383.png" alt="|q| \ll 1" />, these series converge very quickly, so the
Jacobi theta functions can efficiently be evaluated to high
precision.</p>
<p><strong>Examples and basic properties</strong></p>
<p>Considered as functions of <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" />, the Jacobi theta functions may be
viewed as generalizations of the ordinary trigonometric functions
cos and sin. They are periodic functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">1</span><span class="o">/</span><span class="mf">5.</span><span class="p">)</span>
<span class="go">0.117756191842059</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1</span><span class="o">/</span><span class="mf">5.</span><span class="p">)</span>
<span class="go">0.117756191842059</span>
</pre></div>
</div>
<p>Indeed, the series defining the theta functions are essentially
trigonometric Fourier series. The coefficients can be retrieved
using <tt class="xref docutils literal"><span class="pre">fourier()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">fourier</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">],</span> <span class="mf">4</span><span class="p">))</span>
<span class="go">([0.0, 1.68179, 0.0, 0.420448, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0])</span>
</pre></div>
</div>
<p>The Jacobi theta functions are also so-called quasiperiodic
functions of <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" /> and <img src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" />, meaning that for fixed <img src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" />,
<img src="_images/math/c3cf9a7b93535d07185603a625973776a711146a.png" alt="\vartheta_n(z, q)" /> and <img src="_images/math/8033b3c805ad08f4434c5ce0f3a1e63e8e319a8d.png" alt="\vartheta_n(z+\pi \tau, q)" /> are the same
except for an exponential factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">j</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mf">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="n">tau</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">(-0.682420280786035 + 1.5266839997214j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="o">*</span><span class="n">j</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="n">q</span> <span class="o">*</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">(-0.682420280786035 + 1.5266839997214j)</span>
</pre></div>
</div>
<p>The Jacobi theta functions satisfy a huge number of other
functional equations, such as the following identity (valid for
any <img src="_images/math/0615acc3725de21025457e7d6f7694dab8e2f758.png" alt="q" />):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">3</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mf">4</span>
<span class="go">6.82374408935276</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mf">4</span> <span class="o">+</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mf">4</span>
<span class="go">6.82374408935276</span>
</pre></div>
</div>
<p>Extensive listings of identities satisfied by the Jacobi theta
functions can be found in standard reference works.</p>
<p>The Jacobi theta functions are related to the gamma function
for special arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">3</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="p">))</span>
<span class="go">1.08643481121331</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="mf">3</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span>
<span class="go">1.08643481121331</span>
</pre></div>
</div>
<p><tt class="xref docutils literal"><span class="pre">jtheta()</span></tt> supports arbitrary precision evaluation and complex
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0549510717571539127004115835148878097035750653737</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">4</span><span class="p">,</span> <span class="mf">1</span><span class="o">+</span><span class="mf">2</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mf">5</span><span class="p">)</span>
<span class="go">(7.180331760146805926357227 - 1.634292858119162417301859j)</span>
</pre></div>
</div>
<p><strong>Possible issues</strong></p>
<p>For <img src="_images/math/e7f46a50bae4c4ba199b8f1eba5497c4d8751d40.png" alt="|q| \ge 1" /> or <img src="_images/math/22a257eca6d85bb59e15945d8ac6309a92cbe915.png" alt="\Im(\tau) \le 0" />, <tt class="xref docutils literal"><span class="pre">jtheta()</span></tt> raises
<tt class="docutils literal"><span class="pre">ValueError</span></tt>. This exception is also raised for <img src="_images/math/f3e0d75c3450ca8f389d08d904ed1fc695734539.png" alt="|q|" /> extremely
close to 1 (or equivalently <img src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" /> very close to 0), since the
series would converge too slowly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">jtheta</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">0.99999999</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">j</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">abs(q) &gt; Q_LIM = 1.000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.djtheta">
<!--[mpmath.elliptic.djtheta]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">djtheta</tt><big>(</big><em>n</em>, <em>z</em>, <em>q</em>, <em>nd=1</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.djtheta" title="Permalink to this definition">¶</a></dt>
<dd><p>For an integer <img src="_images/math/9a92ea6e07906749a1450f2ca0a6aa314892ae04.png" alt="nd \ge 1" />, computes the <img src="_images/math/56d18fe37d0a4ef803d3c18da7382c157b40696f.png" alt="nd" />:th derivative with
respect to <img src="_images/math/b13f21416d84e13708696f34dea81026cda583c9.png" alt="z" /> of the Jacobi theta function <img src="_images/math/67def3b3e0850232194a10e194d3be36d30874e4.png" alt="\vartheta_n(z,q)" />:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">djtheta</span><span class="p">(</span><span class="mf">3</span><span class="p">,</span> <span class="mf">7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="go">-0.795947847483158</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jtheta</span><span class="p">(</span><span class="mf">3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="mf">7</span><span class="p">)</span>
<span class="go">-0.795947847483158</span>
</pre></div>
</div>
<p>For additional details, see <tt class="xref docutils literal"><span class="pre">jtheta()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jsn">
<!--[mpmath.elliptic.jsn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jsn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jsn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic sn function in term
of jacoby theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jcn">
<!--[mpmath.elliptic.jcn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jcn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jcn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic cn function in term
of theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jdn">
<!--[mpmath.elliptic.jdn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jdn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jdn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic dn function in term
of theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Mathematical functions</a><ul>
<li><a class="reference external" href="#constants">Constants</a></li>
<li><a class="reference external" href="#number-parts">Number parts</a></li>
<li><a class="reference external" href="#powers-and-logarithms">Powers and logarithms</a></li>
<li><a class="reference external" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference external" href="#hyperbolic-functions">Hyperbolic functions</a></li>
<li><a class="reference external" href="#exponential-integrals">Exponential integrals</a></li>
<li><a class="reference external" href="#bessel-and-related-functions">Bessel and related functions</a></li>
<li><a class="reference external" href="#gamma-and-related-functions">Gamma and related functions</a></li>
<li><a class="reference external" href="#riemann-zeta-function-bernoulli-numbers-and-related">Riemann zeta function, Bernoulli numbers and related</a></li>
<li><a class="reference external" href="#hypergeometric-functions">Hypergeometric functions</a></li>
<li><a class="reference external" href="#elliptic-functions">Elliptic functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="basics.html" title="previous chapter">Mpmath basics</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="calculus.html" title="next chapter">Numerical calculus</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/functions.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="calculus.html" title="Numerical calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Mpmath basics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Fredrik Johansson.
      Last updated on Nov 15, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>

<!-- Generate pageview statistics when this document is viewed on the mpmath website -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">

if ((""+document.location).match("google"))
{
    _uacct = "UA-2697185-2";
    urchinTracker();
}
</script>
  </body>
</html>