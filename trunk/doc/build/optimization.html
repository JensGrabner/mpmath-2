<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Optimization &mdash; mpmath v0.10-svn documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '',
          VERSION:     '0.10-svn',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html" />
    <link rel="index" title="Global index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="mpmath v0.10-svn documentation" href="index.html" />
    <link rel="next" title="Limits" href="limits.html" />
    <link rel="prev" title="Differentiation" href="differentiation.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="limits.html" title="Limits"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="differentiation.html" title="Differentiation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="optimization">
<h1>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h1>
<div class="section" id="root-finding-with-the-secant-method-findroot">
<h2>Root-finding with the secant method (<tt class="docutils literal"><span class="pre">findroot</span></tt>)<a class="headerlink" href="#root-finding-with-the-secant-method-findroot" title="Permalink to this headline">¶</a></h2>
<p>The function <tt class="docutils literal"><span class="pre">findroot</span></tt> locates a root of a given function using the secant method by default. A simple example use of the secant method is to compute pi as the root of sin(<em>x</em>) closest to <em>x</em> = 3:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">3.14159265358979323846264338328</span>
</pre></div>
<p>The secant method can be used to find complex roots of analytic functions, although it must in that case generally be given a nonreal starting value (or else it will never leave the real line):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">3</span> <span class="o">+</span> <span class="mf">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="go">(0.226698825758202 + 1.46771150871022j)</span>
</pre></div>
<p>A good initial guess for the location of the root is required for the method to be effective, so it is somewhat more appropriate to think of the secant method as a root-polishing method than a root-finding method. When the rough location of the root is known, the secant method can be used to refine it to very high precision in only a few steps. If the root is a first-order root, only roughly log(prec) iterations are required. (The secant method is far less efficient for multiple roots.) It may be worthwhile to compute the initial approximation to a root using a machine precision solver (for example using one of SciPy&#8217;s many solvers), and then refining it to high precision using mpmath&#8217;s <tt class="docutils literal"><span class="pre">findroot</span></tt> method.</p>
<div class="section" id="neat-examples">
<h3>Neat examples<a class="headerlink" href="#neat-examples" title="Permalink to this headline">¶</a></h3>
<p>A nice application is to compute nontrivial roots of the Riemann zeta function with many digits (good initial values are needed for convergence):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">14</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 14.1347251417346937904572519836j)</span>
</pre></div>
<p>The secant method can also be used as an optimization algorithm, by passing it a derivative of a function. The following example locates the positive minimum of the gamma function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">diff</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">1.4616321449683623413</span>
</pre></div>
<p>Finally, a useful application is to compute inverse functions, such as the Lambert W function which is the inverse of <em>w</em> exp(<em>w</em>), given the first term of the solution&#8217;s asymptotic expansion as the initial value. In basic cases, this gives identical results to mpmath&#8217;s builtin <tt class="docutils literal"><span class="pre">lambertw</span></tt> function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lambert</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">x</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambert</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.567143290409784 0.567143290409784</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambert</span><span class="p">(</span><span class="mf">1000</span><span class="p">),</span> <span class="n">lambert</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">5.2496028524016 5.2496028524016</span>
</pre></div>
</div>
<div class="section" id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>Strictly speaking, the secant method requires two initial values. By default, you only have to provide the first point <tt class="docutils literal"><span class="pre">x0</span></tt>; the solver automatically sets the second point (somewhat arbitrarily) to <tt class="docutils literal"><span class="pre">x0</span> <span class="pre">+</span> <span class="pre">1/4</span></tt>. Manually providing also the second point can help in some cases if <tt class="docutils literal"><span class="pre">secant</span></tt> fails to converge. If you provide more than one point, be sure to use a tuple (or a list).</p>
<p>By default, <tt class="docutils literal"><span class="pre">findroot</span></tt> performs a maximum of 30 steps (when using the secant method), which can be increased or decreased using the <tt class="docutils literal"><span class="pre">maxsteps</span></tt> keyword argument. You can pass <tt class="docutils literal"><span class="pre">findroot</span></tt> the option <tt class="docutils literal"><span class="pre">verbose=True</span></tt> to show detailed progress. The keyword <tt class="docutils literal"><span class="pre">tol</span></tt> specifies the maximal tolerated error for the solution. The solver will iterate until the error is smaller or <tt class="docutils literal"><span class="pre">maxsteps</span></tt> is reached.</p>
<p>Usually the secant method will just work, but you can use other solvers if it fails. This is done using the <tt class="docutils literal"><span class="pre">solver</span></tt> keyword. A solver is a class that can be called with <tt class="docutils literal"><span class="pre">(f,</span> <span class="pre">x0,</span> <span class="pre">**kwargs)</span></tt> and returns an iterator yielding tuple consisting of approximative solution and estimated error. So you can implement your own solver, but there are already many available in mpmath; see the <tt class="docutils literal"><span class="pre">mpmath.optimzation</span></tt> module.</p>
</div>
</div>
<div class="section" id="intersection-methods">
<h2>Intersection methods<a class="headerlink" href="#intersection-methods" title="Permalink to this headline">¶</a></h2>
<p>When you need to find a root in a known interval, it&#8217;s highly recommended to
use an intersection-based solver like <tt class="docutils literal"><span class="pre">'anderson'</span></tt> or <tt class="docutils literal"><span class="pre">'ridder'</span></tt>.
Usually the converge faster and more reliable. They have however problems with
multiple roots and usually need a sign change to find a root.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">3</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;anderson&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
</pre></div>
<p>Be careful with symmetric functions:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;anderson&#39;</span><span class="p">)</span> <span class="c">#doctest:+ELLIPSIS</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
  File <span class="nb">&quot;mpmath/settings.py&quot;</span>, line <span class="m">135</span>, in <span class="n-Identifier">g</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  File <span class="nb">&quot;mpmath/optimization.py&quot;</span>, line <span class="m">551</span>, in <span class="n-Identifier">findroot</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>
  File <span class="nb">&quot;mpmath/optimization.py&quot;</span>, line <span class="m">332</span>, in <span class="n-Identifier">__iter__</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">fa</span><span class="o">/</span><span class="n">s</span>
  File <span class="nb">&quot;&lt;string&gt;&quot;</span>, line <span class="m">8</span>, in <span class="n-Identifier">__div__</span>
  File <span class="nb">&quot;.../libmpf.py&quot;</span>, line <span class="m">761</span>, in <span class="n-Identifier">mpf_div</span>
    <span class="k">raise</span> <span class="ne">ZeroDivisionError</span>
<span class="nc">ZeroDivisionError</span>
</pre></div>
<p>It fails even for better starting points, because there is no sign change:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="o">.</span><span class="mf">5</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;anderson&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
  File <span class="nb">&quot;mpmath/settings.py&quot;</span>, line <span class="m">135</span>, in <span class="n-Identifier">g</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  File <span class="nb">&quot;mpmath/optimization.py&quot;</span>, line <span class="m">562</span>, in <span class="n-Identifier">findroot</span>
    <span class="o">%</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">tol</span><span class="p">))</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">Could not find root within given tolerance. (1 &gt; 2.1684e-19)</span>
<span class="go">Try another starting point or tweak arguments.</span>
</pre></div>
</div>
<div class="section" id="multiple-roots">
<h2>Multiple roots<a class="headerlink" href="#multiple-roots" title="Permalink to this headline">¶</a></h2>
<p>For multiple roots all methods of the Newtonian family (including secant) converge slowly. Consider this example:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">1</span><span class="p">)</span><span class="o">**</span><span class="mf">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">mpf(&#39;0.91807354244492868&#39;)</span>
</pre></div>
<p>Even for a very close starting point the secant method converges very slowly. Use <tt class="docutils literal"><span class="pre">verbose=True</span></tt> to illustrate this.</p>
<p>It&#8217;s possible to modify Newton&#8217;s method to make it converge regardless of the root&#8217;s multiplicity.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">10</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;mnewton&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;1.0&#39;)</span>
</pre></div>
<p>This variant uses the first and second derivative of the function, which is not very efficient.</p>
<p>Alternatively you can use an experimental Newtonian solver that keeps track of the speed of convergence and accelerates it using Steffensen&#8217;s method if necessary.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">10</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;anewton&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x: -9.88888888888888888889</span>
<span class="go">error: 0.111111111111111111111</span>
<span class="go">converging slowly</span>
<span class="go">x: -9.77890011223344556678</span>
<span class="go">error: 0.10998877665544332211</span>
<span class="go">converging slowly</span>
<span class="go">x: -9.67002233332199662166</span>
<span class="go">error: 0.108877778911448945119</span>
<span class="go">converging slowly</span>
<span class="go">accelerating convergence</span>
<span class="go">x: -9.5622443299551077669</span>
<span class="go">error: 0.107778003366888854764</span>
<span class="go">converging slowly</span>
<span class="go">x: 0.99999999999999999214</span>
<span class="go">error: 10.562244329955107759</span>
<span class="go">x: 1.0</span>
<span class="go">error: 7.8598304758094664213e-18</span>
<span class="go">mpf(&#39;1.0&#39;)</span>
</pre></div>
<p>It&#8217;s possible to determine the multiplicity of a root using derivatives. You can do this using the function <tt class="docutils literal"><span class="pre">multiplicity</span></tt>.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">multiplicity</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
<p>This will calculate the derivatives numerically if you do not specify them, this can be quite inefficient. Due to this, <tt class="docutils literal"><span class="pre">multiplicity</span></tt> cancels after evaluating 10 derivatives by default.</p>
</div>
<div class="section" id="accelerated-convergence">
<h2>Accelerated convergence<a class="headerlink" href="#accelerated-convergence" title="Permalink to this headline">¶</a></h2>
<p>You can use Steffensen&#8217;s method to accelerate a fixpoint iteration of linear (or less) convergence.</p>
<p>x* is a fixpoint of the iteration x_{k+1} = phi(x_k) if x* = phi(x*). For phi(x) = x**2 there are two fixpoints: 0 and 1.</p>
<p>Let&#8217;s try Steffensen&#8217;s method:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath.optimization</span> <span class="k">import</span> <span class="n">steffensen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">steffensen</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">fx</span> <span class="o">=</span> <span class="n">Fx</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">fx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">Fx</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">Fx</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%20g</span><span class="s">  </span><span class="si">%20g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">Fx</span><span class="p">)</span>
<span class="go">                0.25                  -0.5</span>
<span class="go">              0.0625                   0.1</span>
<span class="go">          0.00390625            -0.0011236</span>
<span class="go">        1.52588e-005          1.41691e-009</span>
<span class="go">        2.32831e-010         -2.84465e-027</span>
<span class="go">        5.42101e-020          2.30189e-080</span>
<span class="go">        2.93874e-039          -1.2197e-239</span>
<span class="go">        8.63617e-078                     0</span>
<span class="go">        7.45834e-155                     0</span>
<span class="go">        5.56268e-309                     0</span>
<span class="go">                0.81               1.02676</span>
<span class="go">              0.6561               1.00134</span>
<span class="go">            0.430467                     1</span>
<span class="go">            0.185302                     1</span>
<span class="go">           0.0343368                     1</span>
<span class="go">          0.00117902                     1</span>
<span class="go">        1.39008e-006                     1</span>
<span class="go">        1.93233e-012                     1</span>
<span class="go">        3.73392e-024                     1</span>
<span class="go">        1.39421e-047                     1</span>
<span class="go">                   4                   1.6</span>
<span class="go">                  16                1.2962</span>
<span class="go">                 256               1.10194</span>
<span class="go">               65536               1.01659</span>
<span class="go">        4.29497e+009               1.00053</span>
<span class="go">        1.84467e+019                     1</span>
<span class="go">        3.40282e+038                     1</span>
<span class="go">        1.15792e+077                     1</span>
<span class="go">        1.34078e+154                     1</span>
<span class="go">        1.34078e+154                     1</span>
</pre></div>
<p>Unmodified, the iteration converges only towards 0. Modified it converges not only much faster, it converges even to the repelling fixpoint 1.</p>
</div>
<div class="section" id="complex-roots">
<h2>Complex roots<a class="headerlink" href="#complex-roots" title="Permalink to this headline">¶</a></h2>
<p>For complex roots it&#8217;s recommended to use Muller&#8217;s method as it converges even for real starting points very fast.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mf">4</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">1</span><span class="p">,</span> <span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;muller&#39;</span><span class="p">)</span>
<span class="go">mpc(real=&#39;0.72713608449119684&#39;, imag=&#39;0.93409928946052944&#39;)</span>
</pre></div>
</div>
<div class="section" id="finding-all-roots-of-a-polynomial-polyroots">
<h2>Finding all roots of a polynomial (<tt class="docutils literal"><span class="pre">polyroots</span></tt>)<a class="headerlink" href="#finding-all-roots-of-a-polynomial-polyroots" title="Permalink to this headline">¶</a></h2>
<p>The function <tt class="docutils literal"><span class="pre">polyroots</span></tt> computes all <em>n</em> real or complex roots of an <em>n</em>-th degree polynomial. It will for example successfully compute the two real roots of 3x^2 - 7x + 2:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">polyroots</span><span class="p">([</span><span class="mf">3</span><span class="p">,</span><span class="o">-</span><span class="mf">7</span><span class="p">,</span><span class="mf">2</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span>
<span class="gp">...</span>
<span class="go">0.333333333333333</span>
<span class="go">2.0</span>
</pre></div>
<p>or the three roots of x^3 - x^2 - 14x + 24:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">polyroots</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="o">-</span><span class="mf">14</span><span class="p">,</span><span class="mf">24</span><span class="p">])</span>
<span class="go">[mpf(&#39;-4.0&#39;), mpf(&#39;2.0&#39;), mpf(&#39;3.0&#39;)]</span>
</pre></div>
<p>The following example computes all the 5th roots of unity; i.e. the roots of x^5 - 1:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">polyroots</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span>
<span class="gp">...</span>
<span class="go">1.0</span>
<span class="go">(-0.8090169943749474241 + 0.58778525229247312917j)</span>
<span class="go">(-0.8090169943749474241 - 0.58778525229247312917j)</span>
<span class="go">(0.3090169943749474241 + 0.95105651629515357212j)</span>
<span class="go">(0.3090169943749474241 - 0.95105651629515357212j)</span>
</pre></div>
<p>Although all roots are internally calculated using complex arithmetic, any root found to have an imaginary part smaller than the estimated numerical error is truncated to a real number. Real roots are placed first in the returned list, sorted by value. The remaining complex numbers are sorted by real their parts so that conjugate roots end up next to each other.</p>
<p>Provided there are no repeated roots, <tt class="docutils literal"><span class="pre">polyroots</span></tt> can typically compute all roots with high precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">70</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">polyroots</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span>
<span class="gp">...</span>
<span class="go">-3.146264369941972342329135065715570445512477129187328701232486717442666</span>
<span class="go">-0.3178372451957822447257576172961742883731333784334325548791272414612005</span>
<span class="go">0.3178372451957822447257576172961742883731333784334325548791272414612005</span>
<span class="go">3.146264369941972342329135065715570445512477129187328701232486717442666</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">3.146264369941972342329135065715570445512477129187328701232486717442665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.3178372451957822447257576172961742883731333784334325548791272414612005</span>
</pre></div>
<div class="section" id="ill-conditioned-polynomials">
<h3>Ill-conditioned polynomials<a class="headerlink" href="#ill-conditioned-polynomials" title="Permalink to this headline">¶</a></h3>
<p>If a root with multiplicity M is present, it can typically only be computed accurately to dps/M digits (an sometimes less, due to slow convergence). For example, a triple root can be expected to be computed to roughly 5 accurate digits at standard 15-digit precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span> <span class="o">=</span> <span class="n">polyroots</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span>
<span class="gp">...</span>
<span class="go">(-1.00000007263211 - 1.9031226565599e-7j)</span>
<span class="go">(-0.999999852005337 + 2.06642147088233e-7j)</span>
<span class="go">(-1.00000162463939 - 1.50181300875847e-6j)</span>
</pre></div>
<p>In these cases the modified Newton method is useful to refine the roots to high accuracy:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">extraprec</span><span class="p">(</span><span class="mf">30</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">polyval</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;mnewton&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(-1.0 + 0.0j)</span>
<span class="go">(-1.0 + 3.0385816786431355991914375262598262893507090667584e-64j)</span>
<span class="go">(-1.0 + 0.0j)</span>
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">extraprec</span></tt> might be needed to ensure accurate evaluation of the polynomial.</p>
<p>An example of an extremely ill-conditioned polynomial is Wilkinson&#8217;s polynomial which has roots at the integers 1 through 20.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2432902008176640000</span><span class="p">,</span> <span class="o">-</span><span class="mf">8752948036761600000</span><span class="p">,</span> <span class="mf">13803759753640704000</span><span class="p">,</span>
<span class="gp">... </span>    <span class="o">-</span><span class="mf">12870931245150988800</span><span class="p">,</span> <span class="mf">8037811822645051776</span><span class="p">,</span> <span class="o">-</span><span class="mf">3599979517947607200</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">1206647803780373360</span><span class="p">,</span> <span class="o">-</span><span class="mf">311333643161390640</span><span class="p">,</span> <span class="mf">63030812099294896</span><span class="p">,</span>
<span class="gp">... </span>    <span class="o">-</span><span class="mf">10142299865511450</span><span class="p">,</span> <span class="mf">1307535010540395</span><span class="p">,</span> <span class="o">-</span><span class="mf">135585182899530</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">11310276995381</span><span class="p">,</span> <span class="o">-</span><span class="mf">756111184500</span><span class="p">,</span> <span class="mf">40171771630</span><span class="p">,</span> <span class="o">-</span><span class="mf">1672280820</span><span class="p">,</span> <span class="mf">53327946</span><span class="p">,</span>
<span class="gp">... </span>    <span class="o">-</span><span class="mf">1256850</span><span class="p">,</span> <span class="mf">20615</span><span class="p">,</span> <span class="o">-</span><span class="mf">210</span><span class="p">,</span> <span class="mf">1</span><span class="p">][::</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span> <span class="o">=</span> <span class="n">polyroots</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span>
<span class="gp">...</span>
<span class="go">1.0</span>
<span class="go">2.0</span>
<span class="go">3.0</span>
<span class="go">4.00000000000184</span>
<span class="go">4.99999999994666</span>
<span class="go">6.00000000011394</span>
<span class="go">7.00000001128901</span>
<span class="go">7.99999998684772</span>
<span class="go">8.99999991431934</span>
<span class="go">9.99999897717367</span>
<span class="go">10.9999998763699</span>
<span class="go">11.9999947045394</span>
<span class="go">13.0000024841578</span>
<span class="go">13.9999973809886</span>
<span class="go">15.0000157682936</span>
<span class="go">16.000000498559</span>
<span class="go">17.0000017669947</span>
<span class="go">18.0000008200121</span>
<span class="go">18.999999711431</span>
<span class="go">20.0000000125722</span>
</pre></div>
<p>All roots have been separated out, but <tt class="docutils literal"><span class="pre">polyroots</span></tt> fails to converge to high accuracy. The roots can however effectively be polished using the secant method:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">extraprec</span><span class="p">(</span><span class="mf">50</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">polyval</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1.0</span>
<span class="go">2.0</span>
<span class="go">3.0</span>
<span class="go">4.0</span>
<span class="go">5.0</span>
<span class="go">6.0</span>
<span class="go">7.0</span>
<span class="go">8.0</span>
<span class="go">9.0</span>
<span class="go">10.0</span>
<span class="go">11.0</span>
<span class="go">12.0</span>
<span class="go">13.0</span>
<span class="go">14.0</span>
<span class="go">15.0</span>
<span class="go">16.0</span>
<span class="go">17.0</span>
<span class="go">18.0</span>
<span class="go">19.0</span>
<span class="go">20.0</span>
</pre></div>
<p>The extra precision ensures that the evaluation of the polynomial is accurate.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">Optimization</a><ul>
<li><a class="reference external" href="#root-finding-with-the-secant-method-findroot">Root-finding with the secant method (<tt class="docutils literal"><span class="pre">findroot</span></tt>)</a><ul>
<li><a class="reference external" href="#neat-examples">Neat examples</a></li>
<li><a class="reference external" href="#options">Options</a></li>
</ul>
</li>
<li><a class="reference external" href="#intersection-methods">Intersection methods</a></li>
<li><a class="reference external" href="#multiple-roots">Multiple roots</a></li>
<li><a class="reference external" href="#accelerated-convergence">Accelerated convergence</a></li>
<li><a class="reference external" href="#complex-roots">Complex roots</a></li>
<li><a class="reference external" href="#finding-all-roots-of-a-polynomial-polyroots">Finding all roots of a polynomial (<tt class="docutils literal"><span class="pre">polyroots</span></tt>)</a><ul>
<li><a class="reference external" href="#ill-conditioned-polynomials">Ill-conditioned polynomials</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="differentiation.html" title="previous chapter">Differentiation</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="limits.html" title="next chapter">Limits</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/optimization.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="limits.html" title="Limits"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="differentiation.html" title="Differentiation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Fredrik Johansson.
      Last updated on Oct 26, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>

<!-- Generate pageview statistics when this document is viewed on the mpmath website -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">

if ((""+document.location).match("google"))
{
    _uacct = "UA-2697185-2";
    urchinTracker();
}
</script>
  </body>
</html>