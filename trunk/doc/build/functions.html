<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mathematical functions &mdash; mpmath v0.10-svn documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '',
          VERSION:     '0.10-svn',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html" />
    <link rel="index" title="Global index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="mpmath v0.10-svn documentation" href="index.html" />
    <link rel="next" title="Numerical calculus" href="calculus.html" />
    <link rel="prev" title="Mpmath basics" href="basics.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="calculus.html" title="Numerical calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Mpmath basics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="mathematical-functions">
<h1><a class="toc-backref" href="#id1">Mathematical functions<a class="headerlink" href="#mathematical-functions" title="Permalink to this headline">¶</a></a></h1>
<p>Mpmath implements the standard functions from Python&#8217;s <tt class="docutils literal"><span class="pre">math</span></tt> and <tt class="docutils literal"><span class="pre">cmath</span></tt> modules, for both real and complex numbers and with arbitrary precision. Many other functions are also available in mpmath, including commonly-used variants of standard functions (such as the alternative trigonometric functions sec, csc, cot), but also a large number of &#8220;special functions&#8221; such as the gamma function, the Riemann zeta function, error functions, Bessel functions, etc.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#mathematical-functions" id="id1">Mathematical functions</a><ul>
<li><a class="reference internal" href="#constants" id="id2">Constants</a></li>
<li><a class="reference internal" href="#number-parts" id="id3">Number parts</a></li>
<li><a class="reference internal" href="#powers-and-logarithms" id="id4">Powers and logarithms</a></li>
<li><a class="reference internal" href="#trigonometric-functions" id="id5">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-functions" id="id6">Hyperbolic functions</a></li>
<li><a class="reference internal" href="#exponential-integrals" id="id7">Exponential integrals</a></li>
<li><a class="reference internal" href="#bessel-and-related-functions" id="id8">Bessel and related functions</a></li>
<li><a class="reference internal" href="#gamma-and-related-functions" id="id9">Gamma and related functions</a></li>
<li><a class="reference internal" href="#riemann-zeta-function-bernoulli-numbers-and-related" id="id10">Riemann zeta function, Bernoulli numbers and related</a></li>
<li><a class="reference internal" href="#hypergeometric-functions" id="id11">Hypergeometric functions</a></li>
<li><a class="reference internal" href="#elliptic-functions" id="id12">Elliptic functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="constants">
<h2><a class="toc-backref" href="#id2">Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></a></h2>
<p>The predefined objects <tt class="xref docutils literal"><span class="pre">j</span></tt> (imaginary unit), <tt class="xref docutils literal"><span class="pre">inf</span></tt> (positive infinity) and <tt class="xref docutils literal"><span class="pre">nan</span></tt> (not-a-number) are shortcuts to <tt class="xref docutils literal"><span class="pre">mpc</span></tt> and <tt class="xref docutils literal"><span class="pre">mpf</span></tt> instances with these fixed values.</p>
<p>Mpmath supports arbitrary-precision computation of various common (and less common) mathematical constants. These constants are implemented as lazy objects that can be computed with any precision. Whenever the objects are used as function arguments or as operands in arithmetic operations, they automagically evaluate to the current working precision. A lazy number can be converted to a regular <tt class="docutils literal"><span class="pre">mpf</span></tt> using the unary <tt class="docutils literal"><span class="pre">+</span></tt> operator:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span>
<span class="go">&lt;pi: 3.14159~&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span>
<span class="go">mpf(&#39;6.2831853071795862&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">pi</span>
<span class="go">mpf(&#39;3.1415926535897931&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span>
<span class="go">&lt;pi: 3.14159~&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span>
<span class="go">mpf(&#39;6.283185307179586476925286766559005768394338&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">pi</span>
<span class="go">mpf(&#39;3.141592653589793238462643383279502884197169&#39;)</span>
</pre></div>
<dl class="attribute">
<dt id="mpmath.functions.pi">
<!--[mpmath.functions.pi]--><tt class="descclassname">functions.</tt><tt class="descname">pi</tt><a class="headerlink" href="#mpmath.functions.pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Pi, roughly equal to 3.141592654, represents the area of the unit
circle, the half-period of trigonometric functions, and many other
things in mathematics.</p>
<p>Mpmath can evaluate pi to arbitrary precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span>
<span class="go">3.1415926535897932384626433832795028841971693993751</span>
</pre></div>
<p>This shows digits 99991-100000 of pi:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">pi</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;5549362464&#39;</span>
</pre></div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">pi</span></tt> always rounds to the nearest floating-point
number when used. This means that exact mathematical identities
involving pi will generally not be preserved in floating-point
arithmetic. In particular, multiples of <tt class="xref docutils literal"><span class="pre">pi</span></tt> (except for 
the trivial case <tt class="docutils literal"><span class="pre">0*pi</span></tt>) are <cite>not</cite> the exact roots of
<tt class="xref docutils literal"><span class="pre">sin()</span></tt>, but differ roughly by the current epsilon:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">mpf(&#39;1.2246467991473532e-16&#39;)</span>
</pre></div>
<p>One solution is to use the <tt class="xref docutils literal"><span class="pre">sinpi()</span></tt> function instead:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sinpi</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
</pre></div>
<p>See the documentation of trigonometric functions for additional
details.</p>
</dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.degree">
<!--[mpmath.functions.degree]--><tt class="descclassname">functions.</tt><tt class="descname">degree</tt><a class="headerlink" href="#mpmath.functions.degree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.e">
<!--[mpmath.functions.e]--><tt class="descclassname">functions.</tt><tt class="descname">e</tt><a class="headerlink" href="#mpmath.functions.e" title="Permalink to this definition">¶</a></dt>
<dd><p>The transcendental number e = 2.718281828... is the base of the
natural logarithm <tt class="xref docutils literal"><span class="pre">ln()</span></tt> and of the exponential function,
<tt class="xref docutils literal"><span class="pre">exp()</span></tt>.</p>
<p>Mpmath can be evaluate e to arbitrary precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span>
<span class="go">2.7182818284590452353602874713526624977572470937</span>
</pre></div>
<p>This shows digits 99991-100000 of e:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;2100427165&#39;</span>
</pre></div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">e</span></tt> always rounds to the nearest floating-point number
when used, and mathematical identities involving e may not
hold in floating-point arithmetic. For example, <tt class="docutils literal"><span class="pre">ln(e)</span></tt>
might not evaluate exactly to 1.</p>
<p>In particular, don&#8217;t use <tt class="docutils literal"><span class="pre">e**x</span></tt> to compute the exponential
function. Use <tt class="docutils literal"><span class="pre">exp(x)</span></tt> instead; this is both faster and more
accurate.</p>
</dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.phi">
<!--[mpmath.functions.phi]--><tt class="descclassname">functions.</tt><tt class="descname">phi</tt><a class="headerlink" href="#mpmath.functions.phi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.euler">
<!--[mpmath.functions.euler]--><tt class="descclassname">functions.</tt><tt class="descname">euler</tt><a class="headerlink" href="#mpmath.functions.euler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.catalan">
<!--[mpmath.functions.catalan]--><tt class="descclassname">functions.</tt><tt class="descname">catalan</tt><a class="headerlink" href="#mpmath.functions.catalan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.apery">
<!--[mpmath.functions.apery]--><tt class="descclassname">functions.</tt><tt class="descname">apery</tt><a class="headerlink" href="#mpmath.functions.apery" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.khinchin">
<!--[mpmath.functions.khinchin]--><tt class="descclassname">functions.</tt><tt class="descname">khinchin</tt><a class="headerlink" href="#mpmath.functions.khinchin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpmath.functions.glaisher">
<!--[mpmath.functions.glaisher]--><tt class="descclassname">functions.</tt><tt class="descname">glaisher</tt><a class="headerlink" href="#mpmath.functions.glaisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Glaisher&#8217;s constant A, also known as the Glaisher-Kinkelin constant,
is a number approximately equal to 1.282427129 that sometimes
appears in formulas related to gamma and zeta functions.</p>
<p>Mpmath can evaluate Glaisher&#8217;s constant to arbitrary precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">glaisher</span>
<span class="go">1.282427129100622636875342568869791727767688927325</span>
</pre></div>
<p>Glaisher&#8217;s constant is defined in terms of the derivative of the
Riemann zeta function. We can verify that the value computed by
<tt class="xref docutils literal"><span class="pre">glaisher</span></tt> is correct using mpmath&#8217;s facilities for numerical
differentiation and arbitrary evaluation of the zeta function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">12</span> <span class="o">-</span> <span class="n">diff</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">))</span>
<span class="go">1.282427129100622636875342568869791727767688927325</span>
</pre></div>
<p>Here is an example of an integral that can be evaluated in
terms of Glaisher&#8217;s constant:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">-0.0428537406502909</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">7</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span><span class="o">/</span><span class="mf">24</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mf">4</span> <span class="o">+</span> <span class="mf">3</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">glaisher</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span>
<span class="go">-0.042853740650291</span>
</pre></div>
<p>Mpmath computes Glaisher&#8217;s constant by applying Euler-Maclaurin
summation to a slowly convergent series. The implementation is
reasonably efficient up to about 10,000 digits. See the source
code for additional details.</p>
<p>References:
<a class="reference external" href="http://mathworld.wolfram.com/Glaisher-KinkelinConstant.html">http://mathworld.wolfram.com/Glaisher-KinkelinConstant.html</a></p>
</dd></dl>

</div>
<div class="section" id="number-parts">
<h2><a class="toc-backref" href="#id3">Number parts<a class="headerlink" href="#number-parts" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.fabs">
<!--[mpmath.functions.fabs]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fabs</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.fabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute value of x converted to a mpmath number:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fabs</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fabs</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;5.0&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.re">
<!--[mpmath.functions.re]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">re</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.re" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the real part of x converted to a mpmath number:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;-1.0&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.im">
<!--[mpmath.functions.im]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">im</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.im" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the imaginary part of x converted to a mpmath number:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpf(&#39;4.0&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.conj">
<!--[mpmath.functions.conj]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">conj</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex conjugate of x converted to a mpmath number:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">mpc(real=&#39;-1.0&#39;, imag=&#39;-4.0&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.floor">
<!--[mpmath.functions.floor]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">floor</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.floor" title="Permalink to this definition">¶</a></dt>
<dd>Computes the floor function of x. Note: returns a floating-point
number, not a Python int. If x is larger than the precision, it will be rounded,
not necessarily in the floor direction.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ceil">
<!--[mpmath.functions.ceil]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ceil</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ceil" title="Permalink to this definition">¶</a></dt>
<dd>Computes the ceiling function of x. Note: returns a floating-point
number, not a Python int. If x is larger than the precision, it will be rounded,
not necessarily in the floor direction.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.arg">
<!--[mpmath.functions.arg]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">arg</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.arg" title="Permalink to this definition">¶</a></dt>
<dd>Returns the complex argument (phase) of x. The returned value is
an mpf instance. The argument is here defined to satisfy
-pi &lt; arg(x) &lt;= pi. On the negative real half-axis, it is taken to
be +pi.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.modf">
<!--[mpmath.functions.modf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">modf</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.modf" title="Permalink to this definition">¶</a></dt>
<dd>Converts x and y to mpf or mpc and returns x % y</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ldexp">
<!--[mpmath.functions.ldexp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ldexp</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.ldexp" title="Permalink to this definition">¶</a></dt>
<dd>Calculate mpf(x) * 2**n efficiently. No rounding is performed.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.frexp">
<!--[mpmath.functions.frexp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">frexp</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.frexp" title="Permalink to this definition">¶</a></dt>
<dd>Convert x to a scaled number y in the range [0.5, 1). Returns
(y, n) such that x = y * 2**n. No rounding is performed.</dd></dl>

</div>
<div class="section" id="powers-and-logarithms">
<h2><a class="toc-backref" href="#id4">Powers and logarithms<a class="headerlink" href="#powers-and-logarithms" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.sqrt">
<!--[mpmath.functions.sqrt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sqrt</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>sqrt(x) computes the principal square root of x. For positive
real numbers, this is simply the  positive square root. For
arbitrary complex numbers, the principal square root is
defined to satisfy sqrt(x) = exp(ln(x)/2).</p>
<p>For all mpmath numbers x, calling sqrt(x) is equivalent to
performing x**0.5.</p>
<p><strong>Examples</strong></p>
<p>Basic examples and limits:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">3.16227766016838</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">4</span><span class="p">)</span>
<span class="go">(0.0 + 2.0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1.09868411346781 + 0.455089860562227j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
<p>Square root evaluation is fast at huge precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="o">-</span><span class="mf">10</span><span class="p">:]</span>
<span class="go">&#39;9329332814&#39;</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">sqrt()</span></tt> supports interval arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">16</span><span class="p">,</span> <span class="mf">100</span><span class="p">))</span>
<span class="go">[4.0, 10.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span>
<span class="go">[1.4142135623730949234, 1.4142135623730951455]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mpi</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span> <span class="o">**</span> <span class="mf">2</span>
<span class="go">[1.9999999999999995559, 2.0000000000000004441]</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cbrt">
<!--[mpmath.functions.cbrt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cbrt</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>cbrt(x) computes the cube root of x. This function is faster and
more accurate than raising to a floating-point fraction:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">125</span><span class="o">**</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;4.9999999999999991&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cbrt</span><span class="p">(</span><span class="mf">125</span><span class="p">)</span>
<span class="go">mpf(&#39;5.0&#39;)</span>
</pre></div>
<p>Every nonzero complex number has three cube roots. This function
returns the cube root defined by exp(ln(x)/3) where the principal
branch of the natural logarithm is used. Note that this does not
give a real cube root for negative real numbers:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cbrt</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">(0.5 + 0.866025403784439j)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.nthroot">
<!--[mpmath.functions.nthroot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">nthroot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.nthroot" title="Permalink to this definition">¶</a></dt>
<dd><p>nthroot(x, n) computes the principal nth root of x, x^(1/n). Here
n must be an integer, and can be negative [x^(-1/n) is 1/(x^(1/n))].
For n = 2 or n = 3, this function is equivalent to calling
<tt class="xref docutils literal"><span class="pre">sqrt()</span></tt> or <tt class="xref docutils literal"><span class="pre">cbrt()</span></tt>. In general, nthroot(x, n) is defined
to compute exp(ln(x)/n).</p>
<p><tt class="xref docutils literal"><span class="pre">nthroot()</span></tt> is implemented to use Newton&#8217;s method for small n.
At high precision, this makes x^(1/n) not much more expensive than
the regular exponentiation, x^n. For very large n, it falls back to
use the exponential function.</p>
<p><tt class="xref docutils literal"><span class="pre">nthroot()</span></tt> is faster and more accurate than raising to a
floating-point fraction:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">16807</span> <span class="o">**</span> <span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="mf">5</span><span class="p">)</span>
<span class="go">mpf(&#39;7.0000000000000009&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nthroot</span><span class="p">(</span><span class="mf">16807</span><span class="p">,</span> <span class="mf">5</span><span class="p">)</span>
<span class="go">mpf(&#39;7.0&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hypot">
<!--[mpmath.functions.hypot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hypot</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.hypot" title="Permalink to this definition">¶</a></dt>
<dd>Returns the Euclidean distance sqrt(x*x + y*y). Both x and y
must be real.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.exp">
<!--[mpmath.functions.exp]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">exp</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.exp" title="Permalink to this definition">¶</a></dt>
<dd>Returns the exponential function of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ln">
<!--[mpmath.functions.ln]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ln</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ln" title="Permalink to this definition">¶</a></dt>
<dd>Returns the natural logarithm of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.log">
<!--[mpmath.functions.log]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">log</tt><big>(</big><em>x</em>, <em>b=None</em><big>)</big><a class="headerlink" href="#mpmath.functions.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the base-b logarithm of x. If b is unspecified, return
the natural (base-e) logarithm. log(x, b) is defined as
log(x)/log(b). log(0) raises ValueError.</p>
<p>The natural logarithm is real if x &gt; 0 and complex if x &lt; 0 or if x
is complex. The principal branch of the complex logarithm is chosen,
for which Im(log(x)) = -pi &lt; arg(x) &lt;= pi.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.log10">
<!--[mpmath.functions.log10]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">log10</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.log10" title="Permalink to this definition">¶</a></dt>
<dd>Base-10 logarithm. Equivalent to log(x,10).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.power">
<!--[mpmath.functions.power]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">power</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.power" title="Permalink to this definition">¶</a></dt>
<dd>Converts x and y to mpf or mpc and returns x**y = exp(y*log(x)).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fibonacci">
<!--[mpmath.functions.fibonacci]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fibonacci</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fibonacci" title="Permalink to this definition">¶</a></dt>
<dd><p>fibonacci(n) computes the nth Fibonacci number F(n). The Fibonacci
numbers are defined by F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2).
This definition is extended to arbitrary real and complex arguments
using the formula:</p>
<pre>          z                  -z
       phi  - cos(z*pi) * phi
F(z) = ------------------------
               sqrt(5)</pre>
<p><tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt> also uses this formula to compute F(n) for extremely
large n, where calculating the exact integer would be wasteful.</p>
<p>For convenience, <tt class="xref docutils literal"><span class="pre">fib()</span></tt> is available as an alias for
<tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt>.</p>
<p><strong>Basic examples</strong></p>
<p>Some small Fibonacci numbers are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">0.0 1.0 1.0 2.0 3.0 5.0 8.0 13.0 21.0 34.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">50</span><span class="p">)</span>
<span class="go">12586269025.0</span>
</pre></div>
<p>The recurrence for F(n) extends backwards to negative n:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">0.0 1.0 -1.0 2.0 -3.0 5.0 -8.0 13.0 -21.0 34.0</span>
</pre></div>
<p>Large Fibonacci numbers will be computed approximately unless
the precision is set high enough:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">200</span><span class="p">)</span>
<span class="go">2.8057117299251e+41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">200</span><span class="p">)</span>
<span class="go">280571172992510140037611932413038677189525.0</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">fibonacci()</span></tt> can compute approximate Fibonacci numbers
of stupendous size:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">25</span><span class="p">)</span>
<span class="go">3.49052338550226e+2089876402499787337692720</span>
</pre></div>
<p><strong>Real and complex arguments</strong></p>
<p>The extended Fibonacci function is an analytic function. The
property F(z) = F(z-1) + F(z-2) holds for arbitrary z:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">2.1170270579161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">2.1170270579161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5248.51130728372 - 14195.962288353j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5248.51130728372 - 14195.962288353j)</span>
</pre></div>
<p>The Fibonacci function has infinitely many roots on the
negative half-real axis. The first root is at 0, the second is
close to -0.18, and then there are infinitely many roots that
asymptotically approach -n+1/2:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
<span class="go">-0.183802359692956</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-1.57077646820395</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">17</span><span class="p">)</span>
<span class="go">-16.4999999596115</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="o">-</span><span class="mf">24</span><span class="p">)</span>
<span class="go">-23.5000000000479</span>
</pre></div>
<p><strong>Mathematical relationships</strong></p>
<p>For large n, F(n+1)/F(n) approaches the golden ratio:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mf">101</span><span class="p">)</span><span class="o">/</span><span class="n">fibonacci</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">1.6180339887498948482045868343656381177203127439638</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span>
<span class="go">1.6180339887498948482045868343656381177203091798058</span>
</pre></div>
<p>The sum of reciprocal Fibonacci numbers converges to an irrational
number for which no closed form expression is known:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">3.35988566624318</span>
</pre></div>
<p>Amazingly, however, the sum of odd-index reciprocal Fibonacci
numbers can be expressed in terms of a Jacobi theta function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.82451515740692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="o">*</span><span class="n">jtheta</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">,(</span><span class="mf">3</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">5</span><span class="p">))</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="o">/</span><span class="mf">4</span>
<span class="go">1.82451515740692</span>
</pre></div>
<p>Some related sums can be done in closed form:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">)),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.11803398874989</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="go">1.11803398874989</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mf">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.618033988749895</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">phi</span><span class="o">-</span><span class="mf">1</span>
<span class="go">0.618033988749895</span>
</pre></div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/FibonacciNumber.html">http://mathworld.wolfram.com/FibonacciNumber.html</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.lambertw">
<!--[mpmath.functions.lambertw]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">lambertw</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.lambertw" title="Permalink to this definition">¶</a></dt>
<dd><p>The Lambert W function W(z) is defined as the inverse function
of w*exp(w). In other words, the value of W(z) is such that
z = W(z)*exp(W(z)) for any complex number z.</p>
<p>The Lambert W function is a multivalued function with infinitely
many branches. Each branch gives a separate solution of the
equation w*exp(w). All branches are supported by <tt class="xref docutils literal"><span class="pre">lambertw()</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">lambertw(z)</span></tt> gives the principal solution (branch 0)</li>
<li><tt class="docutils literal"><span class="pre">lambertw(z,</span> <span class="pre">k)</span></tt> gives the solution on branch k</li>
</ul>
<p>The Lambert W function has two partially real branches: the
principal branch (k = 0) is real for real z &gt; -1/e, and the
k = -1 branch is real for -1/e &lt; z &lt; 0. All branches except
k = 0 have a logarithmic singularity at 0.</p>
<p><strong>Basic examples</strong></p>
<p>The Lambert W equation is the inverse of w*exp(w):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span>
<span class="go">0.56714329040978387299996866221035555</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
<p>Any branch gives a valid inverse:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span>    <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">(-2.8535817554090378072068187234910812 + </span>
<span class="go">  17.113535539412145912607826671159289j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">(1.0 + 3.5075477124212226194278700785075126e-36j)</span>
</pre></div>
<p><strong>Applications to equation-solving</strong></p>
<p>The Lambert W function can give the value of the infinite power
tower z^(z^(z^(...))):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">tower</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">z</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">z</span> <span class="o">**</span> <span class="n">tower</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tower</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">100</span><span class="p">)</span>
<span class="go">0.641185744504986</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.6411857445049859844862004821148236665628209571911</span>
</pre></div>
<p><strong>Properties</strong></p>
<p>The Lambert W function grows roughly like the natural logarithm
for large arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">5.2496028524016</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">6.90775527898214</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">224.843106445119</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">log</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">230.258509299405</span>
</pre></div>
<p>The principal branch of the Lambert W function has a rational
Taylor series expansion around 0:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">taylor</span><span class="p">(</span><span class="n">lambertw</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">6</span><span class="p">),</span> <span class="mf">10</span><span class="p">)</span>
<span class="go">[0.0, 1.0, -1.0, 1.5, -2.666666667, 5.208333333, -10.8]</span>
</pre></div>
<p>Some special values and limits are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.567143290409784</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
<p>The k = 0 and k = -1 branches join at z = -1/e where W(z) = -1
for both branches. Since -1/e can only be represented approximately
with mpmath numbers, evaluating the Lambert W function at this point
only gives -1 approximately:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">-0.999999999999837133022867</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-1.00000000000016286697718</span>
</pre></div>
<p>If -1/e happens to round in the negative direction, there might be
a small imaginary part:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">/</span><span class="n">e</span><span class="p">)</span>
<span class="go">(-1.0 + 8.22007971511612e-9j)</span>
</pre></div>
<p><strong>Possible issues</strong></p>
<p>The evaluation can become inaccurate very close to the branch point
at -1/e. In some corner cases, <tt class="xref docutils literal"><span class="pre">lambertw()</span></tt> might currently
fail to converge, or can end up on the wrong branch.</p>
<p><strong>Algorithm</strong></p>
<p>Halley&#8217;s iteration is used to invert w*exp(w), using a first-order
asymptotic approximation (O(log(w)) or O(w)) as the initial estimate.</p>
<p>The definition, implementation and choice of branches is based
on Corless et al, &#8220;On the Lambert W function&#8221;, Adv. Comp. Math. 5
(1996) 329-359, available online here:
<a class="reference external" href="http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf">http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf</a></p>
<p>TODO: use a series expansion when extremely close to the branch point
at -1/e and make sure that the proper branch is chosen there</p>
</dd></dl>

</div>
<div class="section" id="trigonometric-functions">
<h2><a class="toc-backref" href="#id5">Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.degrees">
<!--[mpmath.functions.degrees]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">degrees</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.degrees" title="Permalink to this definition">¶</a></dt>
<dd>Convert x given in radians to degrees</dd></dl>

<dl class="function">
<dt id="mpmath.functions.radians">
<!--[mpmath.functions.radians]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">radians</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.radians" title="Permalink to this definition">¶</a></dt>
<dd>Convert x given in degrees to radians</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cos">
<!--[mpmath.functions.cos]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cos</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cos" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sin">
<!--[mpmath.functions.sin]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sin</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sin" title="Permalink to this definition">¶</a></dt>
<dd>Returns the sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.tan">
<!--[mpmath.functions.tan]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">tan</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.tan" title="Permalink to this definition">¶</a></dt>
<dd>Returns the tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sec">
<!--[mpmath.functions.sec]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.sec" title="Permalink to this definition">¶</a></dt>
<dd>Returns the secant of x, 1/cos(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.csc">
<!--[mpmath.functions.csc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">csc</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.csc" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cosecant of x, 1/sin(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cot">
<!--[mpmath.functions.cot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cot</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.cot" title="Permalink to this definition">¶</a></dt>
<dd>Returns the cotangent of x, 1/tan(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.cospi">
<!--[mpmath.functions.cospi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cospi</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cospi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes cos(pi*x), more accurately than the expression <tt class="docutils literal"><span class="pre">cos(pi*x)</span></tt>:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cospi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">))</span>
<span class="go">1.0 0.999999999997493</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cospi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">0.0 1.59960492420134e-6</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinpi">
<!--[mpmath.functions.sinpi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinpi</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes sin(pi*x), more accurately than the expression <tt class="docutils literal"><span class="pre">sin(pi*x)</span></tt>:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinpi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">))</span>
<span class="go">0.0 -2.23936276195592e-6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinpi</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">1.0 0.999999999998721</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinc">
<!--[mpmath.functions.sinc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinc</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>sinc(x) computes the unnormalized sinc function, defined as
sinc(x) = sin(x)/x and with the singularity at x = 0 removed
so that sinc(0) = 1. See <tt class="xref docutils literal"><span class="pre">sincpi()</span></tt> for the normalized
sinc function.</p>
<p>Simple values and limits include:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.841470984807897</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sinc</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
<p>The integral of the sinc function is the sine integral Si:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">sinc</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.946083070367183</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">si</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.946083070367183</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sincpi">
<!--[mpmath.functions.sincpi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sincpi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sincpi" title="Permalink to this definition">¶</a></dt>
<dd><p>sincpi(x) computes the normalized sinc function, sinc(pi*x)/(pi*x).
This normalization entails that the function integrates
to unity over the entire real line:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quadosc</span><span class="p">(</span><span class="n">sincpi</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
<p>Like, <tt class="xref docutils literal"><span class="pre">sinpi()</span></tt>, <tt class="xref docutils literal"><span class="pre">sincpi()</span></tt> is evaluated accurately
at its roots:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sincpi</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acos">
<!--[mpmath.functions.acos]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acos</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.acos" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asin">
<!--[mpmath.functions.asin]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asin</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.asin" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atan">
<!--[mpmath.functions.atan]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atan</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.atan" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atan2">
<!--[mpmath.functions.atan2]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atan2</tt><big>(</big><em>y</em>, <em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.atan2" title="Permalink to this definition">¶</a></dt>
<dd>atan2(y, x) has the same magnitude as atan(y/x) but accounts for
the signs of y and x. (Defined for real x and y only.)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asec">
<!--[mpmath.functions.asec]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asec</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.asec" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse secant of x, acos(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acsc">
<!--[mpmath.functions.acsc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acsc</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acsc" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cosecant of x, asin(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acot">
<!--[mpmath.functions.acot]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acot</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acot" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse cotangent of x, atan(1/x)</dd></dl>

</div>
<div class="section" id="hyperbolic-functions">
<h2><a class="toc-backref" href="#id6">Hyperbolic functions<a class="headerlink" href="#hyperbolic-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.cosh">
<!--[mpmath.functions.cosh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">cosh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.cosh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sinh">
<!--[mpmath.functions.sinh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sinh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.sinh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.tanh">
<!--[mpmath.functions.tanh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">tanh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.tanh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.sech">
<!--[mpmath.functions.sech]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">sech</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.sech" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic secant of x, 1/cosh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.csch">
<!--[mpmath.functions.csch]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">csch</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.csch" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cosecant of x, 1/sinh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.coth">
<!--[mpmath.functions.coth]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">coth</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.coth" title="Permalink to this definition">¶</a></dt>
<dd>Returns the hyperbolic cotangent of x, 1/tanh(x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acosh">
<!--[mpmath.functions.acosh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acosh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.acosh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cosine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asinh">
<!--[mpmath.functions.asinh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asinh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.asinh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic sine of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.atanh">
<!--[mpmath.functions.atanh]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">atanh</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.atanh" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic tangent of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.asech">
<!--[mpmath.functions.asech]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">asech</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.asech" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic secant of x, acosh(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acsch">
<!--[mpmath.functions.acsch]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acsch</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acsch" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cosecant of x, asinh(1/x)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.acoth">
<!--[mpmath.functions.acoth]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">acoth</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#mpmath.functions.acoth" title="Permalink to this definition">¶</a></dt>
<dd>Returns the inverse hyperbolic cotangent of x, atanh(1/x)</dd></dl>

</div>
<div class="section" id="exponential-integrals">
<h2><a class="toc-backref" href="#id7">Exponential integrals<a class="headerlink" href="#exponential-integrals" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.erf">
<!--[mpmath.functions.erf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erf</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the error function, erf(z). The error function is
the antiderivative of the Gaussian function exp(-t^2). More
precisely:</p>
<pre>                z
                 -
           2    |          2
erf(z) = -----  |   exp( -t ) dt
           1/2  |
         pi    -
                0</pre>
<p><strong>Basic examples</strong></p>
<p>Simple values and limits include:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.842700792949715</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.842700792949715</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-1.0</span>
</pre></div>
<p>For large real z, erf(z) approaches 1 very rapidly:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.999977909503001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
<span class="go">0.999999999998463</span>
</pre></div>
<p>The error function is an odd function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">(</span><span class="n">taylor</span><span class="p">(</span><span class="n">erf</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">5</span><span class="p">))</span>
<span class="go">[0.0, 1.12838, 0.0, -0.376126, 0.0, 0.112838]</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">erf()</span></tt> implements arbitrary-precision evaluation and
supports complex numbers:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.52049987781304653768274665389196452873645157575796</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1.316151281697947644880271 + 0.1904534692378346862841089j)</span>
</pre></div>
<p><strong>Related functions</strong></p>
<p>See also <tt class="xref docutils literal"><span class="pre">erfc()</span></tt>, which is more accurate for large z,
and <tt class="xref docutils literal"><span class="pre">erfi()</span></tt> which gives the antiderivative of exp(t^2).</p>
<p>The Fresnel integrals <tt class="xref docutils literal"><span class="pre">fresnels()</span></tt> and <tt class="xref docutils literal"><span class="pre">fresnelc()</span></tt>
are also related to the error function.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfc">
<!--[mpmath.functions.erfc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfc</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the complementary error function, erfc(z) = 1-erf(z).
This function avoids cancellation that occurs when naively
computing the complementary error function as 1-erf(z):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">1</span> <span class="o">-</span> <span class="n">erf</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfc</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">2.08848758376254e-45</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">erfc()</span></tt> works accurately even for ludicrously large
arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfc</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">10</span><span class="p">)</span>
<span class="go">4.3504398860243e-43429448190325182776</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfi">
<!--[mpmath.functions.erfi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the imaginary error function, erfi(z). The imaginary
error function is defined in analogy with the error function,
but with a positive sign in the integrand:</p>
<pre>                z
                 -
           2    |         2
erf(z) = -----  |   exp( t ) dt
           1/2  |
         pi    -
                0</pre>
<p>Whereas the error function rapidly converges to 1 as z grows,
the imaginary error function rapidly diverges to infinity.
The functions are related as erfi(z) = -j*erf(z*j).</p>
<p><strong>Examples</strong></p>
<p>Basic values and limits:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">1.65042575879754</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-1.65042575879754</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
<p>Note the symmetry between erf and erfi:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.0 + 0.999977909503001j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">0.999977909503001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">2</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-0.536643565778565 - 5.04914370344703j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfi</span><span class="p">(</span><span class="mf">2</span><span class="o">+</span><span class="mf">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-5.04914370344703 - 0.536643565778565j)</span>
</pre></div>
<p><strong>Possible issues</strong></p>
<p>The current implementation of <tt class="xref docutils literal"><span class="pre">erfi()</span></tt> is much less efficient
and accurate than the one for erf.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.erfinv">
<!--[mpmath.functions.erfinv]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">erfinv</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.erfinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse error function, satisfying erf(erfinv(x)) =
erfinv(erf(x)) = x. This function is defined only for -1 &lt;= x &lt;= 1.</p>
<p><strong>Examples</strong></p>
<p>Special values include:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erfinv</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
<p>The domain is limited to the standard interval:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">erfinv</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="nc">ValueError</span>: <span class="n-Identifier">erfinv(x) is defined only for -1 &lt;= x &lt;= 1</span>
</pre></div>
<p>It is simple to check that <tt class="xref docutils literal"><span class="pre">erfinv()</span></tt> computes inverse values of
<tt class="xref docutils literal"><span class="pre">erf()</span></tt> as promised:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">erfinv</span><span class="p">(</span><span class="mf">0.75</span><span class="p">))</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">erf</span><span class="p">(</span><span class="n">erfinv</span><span class="p">(</span><span class="o">-</span><span class="mf">0.995</span><span class="p">))</span>
<span class="go">-0.995</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">erfinv()</span></tt> supports arbitrary-precision evaluation:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erf</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">mpf(&#39;0.99997790950300141455862722387041767962015229291260075&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erfinv</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">mpf(&#39;3.0&#39;)</span>
</pre></div>
<p>A definite integral involving the inverse error function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">erfinv</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.564189583547756</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.564189583547756</span>
</pre></div>
<p>The inverse error function can be used to generate random numbers
with a Gaussian distribution (although this is a relatively
inefficient algorithm):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="n">erfinv</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">rand</span><span class="p">()</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">6</span><span class="p">)])</span> <span class="c"># doctest: +SKIP</span>
<span class="go">[-0.586747, 1.10233, -0.376796, 0.926037, -0.708142, -0.732012]</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.npdf">
<!--[mpmath.functions.npdf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">npdf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.npdf" title="Permalink to this definition">¶</a></dt>
<dd><p>npdf(x, mu=0, sigma=1) &#8211; probability density function of a
normal distribution with mean value mu and variance sigma^2.</p>
<p>Elementary properties of the probability distribution can
be verified using numerical integration:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">npdf</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">npdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">3</span><span class="p">),</span> <span class="p">[</span><span class="mf">3</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">npdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">3</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.5</span>
</pre></div>
<p>See also <tt class="xref docutils literal"><span class="pre">ncdf()</span></tt>, which gives the cumulative
distribution.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ncdf">
<!--[mpmath.functions.ncdf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ncdf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ncdf" title="Permalink to this definition">¶</a></dt>
<dd><p>ncdf(x, mu=0, sigma=1) &#8211; cumulative distribution function of
a normal distribution with mean value mu and variance sigma^2.</p>
<p>See also <tt class="xref docutils literal"><span class="pre">npdf()</span></tt>, which gives the probability density.</p>
<p>Elementary properties include:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ncdf</span><span class="p">(</span><span class="o">+</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
<p>The cumulative distribution is the integral of the density
function having identical mu and sigma:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="n">ncdf</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.053990966513188</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">npdf</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.053990966513188</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ncdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">0.107981933026376</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">npdf</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.107981933026376</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ei">
<!--[mpmath.functions.ei]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ei</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ei" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the exponential integral, Ei(z). The exponential
integral is defined as the following integral (which,
at t = 0, must be interpreted as a Cauchy principal value):</p>
<pre>         z
          -    t
         |    e
Ei(z) =  |   ---- dt
         |    t
        -
        -oo</pre>
<p>For real z, it can be thought of as behaving roughly
like Ei(z) ~= exp(z) + log(abs(z)).</p>
<p>This function should not be confused with the family of
related functions denoted by E1, E2, ... which are also
called exponential integrals.</p>
<p><strong>Basic examples</strong></p>
<p>Some basic values and limits are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">1.89511781635594</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="o">-</span><span class="n">inf</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
<p>For z &lt; 0, the defining integral can be evaluated
numerically as a reference:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="o">-</span><span class="mf">4</span><span class="p">)</span>
<span class="go">-0.00377935240984891</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="mf">4</span><span class="p">])</span>
<span class="go">-0.00377935240984891</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">ei()</span></tt> supports complex arguments and arbitrary
precision evaluation:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">10.928374389331410348638445906907535171566338835056</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(-4.154091651642689822535359 + 4.294418620024357476985535j)</span>
</pre></div>
<p><strong>Related functions</strong></p>
<p>The exponential integral is closely related to the logarithmic
integral. See <tt class="xref docutils literal"><span class="pre">li()</span></tt> for additional information.</p>
<p>The exponential integral is related to the hyperbolic
and trigonometric integrals (see <tt class="xref docutils literal"><span class="pre">chi()</span></tt>, <tt class="xref docutils literal"><span class="pre">shi()</span></tt>,
<tt class="xref docutils literal"><span class="pre">ci()</span></tt>, <tt class="xref docutils literal"><span class="pre">si()</span></tt>) similarly to how the ordinary
exponential function is related to the hyperbolic and
trigonometric functions:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">9.93383257062542</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">chi</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">shi</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">9.93383257062542</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ci</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span><span class="o">*</span><span class="n">si</span><span class="p">(</span><span class="mf">3</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="mf">2</span>
<span class="go">(9.93383257062542 + 0.0j)</span>
</pre></div>
<p>Beware that logarithmic corrections, as in the last example
above, are required to obtain the correct branch in general.
For details, see [1].</p>
<p>The exponential integral is also a special case of the
hypergeometric function 2F2:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">z</span><span class="o">*</span><span class="n">hyper</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">],[</span><span class="mf">2</span><span class="p">,</span><span class="mf">2</span><span class="p">],</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="n">z</span><span class="p">))</span><span class="o">/</span><span class="mf">2</span> <span class="o">+</span> <span class="n">euler</span>
<span class="go">0.769881289937359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">0.769881289937359</span>
</pre></div>
<p><strong>References</strong></p>
<dl class="docutils">
<dt>[1] Relations between Ei and other functions:</dt>
<dd><a class="reference external" href="http://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/27/01/">http://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/27/01/</a></dd>
<dt>[2] Abramowitz &amp; Stegun, section 5:</dt>
<dd><a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_228.htm">http://www.math.sfu.ca/~cbm/aands/page_228.htm</a></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.li">
<!--[mpmath.functions.li]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">li</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.li" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Logarithmic integral, li(z).</p>
<p>The logarithmic integral is defined as the integral from 0 to z
of 1/ln(t). It has a singularity at z = 1.</p>
<p>Note that there is a second logarithmic integral defined by
Li(z) = integral from 2 to z of 1/ln(t). This &#8220;offset
logarithmic integral&#8221; can be computed as Li(z) = li(z) - li(2).</p>
<p><strong>Examples</strong></p>
<p>Some basic values and limits:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">1.04516378011749278484458888919</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">1.45136923488338105028396848589</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
<p>The logarithmic integral can be evaluated for arbitrary
complex arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(3.1343755504645775265 + 2.6769247817778742392j)</span>
</pre></div>
<p>The logarithmic integral is related to the exponential integral:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ei</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mf">3</span><span class="p">))</span>
<span class="go">2.1635885946671919729</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span>
<span class="go">2.1635885946671919729</span>
</pre></div>
<p>The logarithmic integral grows like O(x/ln(x)):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">10</span><span class="o">**</span><span class="mf">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4.34294481903252e+97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4.3619719871407e+97</span>
</pre></div>
<p>The prime number theorem states that the number of primes less
than x is asymptotic to li(x). For example, it is known that
there are exactly 1,925,320,391,606,803,968,923 prime numbers
less than 10^23 [1]. The logarithmic integral provides a very
accurate estimate:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">li</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">li</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">23</span><span class="p">)</span>
<span class="go">1.92532039161405e+21</span>
</pre></div>
<p>A definite integral is:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">-0.693147180559945</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-0.693147180559945</span>
</pre></div>
<p><strong>References</strong></p>
<p>[1] <a class="reference external" href="http://mathworld.wolfram.com/PrimeCountingFunction.html">http://mathworld.wolfram.com/PrimeCountingFunction.html</a></p>
<p>[2] <a class="reference external" href="http://mathworld.wolfram.com/LogarithmicIntegral.html">http://mathworld.wolfram.com/LogarithmicIntegral.html</a></p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ci">
<!--[mpmath.functions.ci]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ci</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ci" title="Permalink to this definition">¶</a></dt>
<dd>Cosine integral, Ci(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.si">
<!--[mpmath.functions.si]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">si</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.si" title="Permalink to this definition">¶</a></dt>
<dd>Sine integral, Si(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chi">
<!--[mpmath.functions.chi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chi" title="Permalink to this definition">¶</a></dt>
<dd>Hyperbolic cosine integral, Chi(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.shi">
<!--[mpmath.functions.shi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">shi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.shi" title="Permalink to this definition">¶</a></dt>
<dd>Hyperbolic sine integral, Shi(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fresnels">
<!--[mpmath.functions.fresnels]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fresnels</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fresnels" title="Permalink to this definition">¶</a></dt>
<dd>Fresnel integral S, S(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.fresnelc">
<!--[mpmath.functions.fresnelc]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">fresnelc</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.fresnelc" title="Permalink to this definition">¶</a></dt>
<dd>Fresnel integral C, C(z)</dd></dl>

</div>
<div class="section" id="bessel-and-related-functions">
<h2><a class="toc-backref" href="#id8">Bessel and related functions<a class="headerlink" href="#bessel-and-related-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.jv">
<!--[mpmath.functions.jv]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">jv</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.jv" title="Permalink to this definition">¶</a></dt>
<dd>Bessel function J_v(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.airyai">
<!--[mpmath.functions.airyai]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">airyai</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.airyai" title="Permalink to this definition">¶</a></dt>
<dd>Airy function, Ai(z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.airybi">
<!--[mpmath.functions.airybi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">airybi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.airybi" title="Permalink to this definition">¶</a></dt>
<dd>Airy function, Bi(z)</dd></dl>

</div>
<div class="section" id="gamma-and-related-functions">
<h2><a class="toc-backref" href="#id9">Gamma and related functions<a class="headerlink" href="#gamma-and-related-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.gamma">
<!--[mpmath.functions.gamma]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">gamma</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.gamma" title="Permalink to this definition">¶</a></dt>
<dd>Returns the gamma function of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.beta">
<!--[mpmath.functions.beta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">beta</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#mpmath.functions.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the beta function, B(x,y) = gamma(x)*gamma(y)/gamma(x+y).
The beta function is also commonly defined by the integral
representation:</p>
<pre>         1
          -
         |   x-1     y-1
B(x,y) = |  t   (1-t)    dt
         |
        -
         0</pre>
<p><strong>Examples</strong></p>
<p>For integer and half-integer arguments where all three gamma
functions are finite, the beta function becomes either rational
number or a rational multiple of pi:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">5</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.0333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">0.266666666666667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mf">16</span><span class="o">*</span><span class="n">beta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
</pre></div>
<p>Where appropriate, <tt class="xref docutils literal"><span class="pre">beta()</span></tt> evaluates limits. A pole
of the beta function is taken to result in <tt class="docutils literal"><span class="pre">+inf</span></tt>:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">-0.333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">+inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">beta()</span></tt> supports complex numbers and arbitrary precision
evaluation:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.4 - 0.2j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">(1.079424249270925780135675 - 1.410032405664160838288752j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="go">0.037890298781212201348153837138927165984170287886464</span>
</pre></div>
<p>Various integrals can be computed by means of the
beta function:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">**</span><span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1</span><span class="p">])</span>
<span class="go">0.0230880230880231</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="go">0.0230880230880231</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mf">4</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2</span><span class="p">])</span>
<span class="go">0.319504062596158</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">beta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span>
<span class="go">0.319504062596158</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.factorial">
<!--[mpmath.functions.factorial]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">factorial</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.factorial" title="Permalink to this definition">¶</a></dt>
<dd>Returns the factorial of x</dd></dl>

<dl class="function">
<dt id="mpmath.functions.binomial">
<!--[mpmath.functions.binomial]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">binomial</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#mpmath.functions.binomial" title="Permalink to this definition">¶</a></dt>
<dd>Binomial coefficient, C(n,k) = n!/(k!*(n-k)!).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.gammaprod">
<!--[mpmath.functions.gammaprod]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">gammaprod</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#mpmath.functions.gammaprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Given iterables <cite>a</cite> and <cite>b</cite>, <tt class="docutils literal"><span class="pre">gammaprod(a,</span> <span class="pre">b)</span></tt> computes the
product / quotient of gamma functions:</p>
<pre>gamma(a[0]) * gamma(a[1]) * ... * gamma(a[p])
---------------------------------------------
gamma(b[0]) * gamma(b[1]) * ... * gamma(b[q])</pre>
<p><strong>Handling of poles</strong></p>
<p>Unlike direct calls to <tt class="xref docutils literal"><span class="pre">gamma()</span></tt>, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt> considers
the entire product as a limit and evaluates this limit properly if
any of the numerator or denominator arguments are nonpositive
integers such that poles of the gamma function are encountered.</p>
<p>In particular:</p>
<ul class="simple">
<li>If there are equally many poles in the numerator and the
denominator, the limit is a rational number times the remaining,
regular part of the product.</li>
<li>If there are more poles in the numerator, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt>
returns <tt class="docutils literal"><span class="pre">+inf</span></tt>.</li>
<li>If there are more poles in the denominator, <tt class="xref docutils literal"><span class="pre">gammaprod()</span></tt>
returns zero (<tt class="docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
<p><strong>Examples</strong></p>
<p>1/gamma(x) evaluated at x = 0:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gammaprod</span><span class="p">([],</span> <span class="p">[</span><span class="mf">0</span><span class="p">])</span>
<span class="go">mpf(&#39;0.0&#39;)</span>
</pre></div>
<p>A limit:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gammaprod</span><span class="p">([</span><span class="o">-</span><span class="mf">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">3</span><span class="p">])</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="mf">3</span><span class="p">,</span> <span class="n">direction</span><span class="o">=-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">mpf(&#39;-0.25&#39;)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.rf">
<!--[mpmath.functions.rf]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">rf</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.rf" title="Permalink to this definition">¶</a></dt>
<dd>Rising factorial (Pochhammer symbol), x^(n)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ff">
<!--[mpmath.functions.ff]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ff</tt><big>(</big><em>x</em>, <em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.ff" title="Permalink to this definition">¶</a></dt>
<dd>Falling factorial, x_(n)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.lower_gamma">
<!--[mpmath.functions.lower_gamma]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">lower_gamma</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.lower_gamma" title="Permalink to this definition">¶</a></dt>
<dd>Lower incomplete gamma function gamma(a, z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.upper_gamma">
<!--[mpmath.functions.upper_gamma]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">upper_gamma</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.upper_gamma" title="Permalink to this definition">¶</a></dt>
<dd>Upper incomplete gamma function Gamma(a, z)</dd></dl>

<dl class="function">
<dt id="mpmath.functions.psi">
<!--[mpmath.functions.psi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">psi</tt><big>(</big><em>m</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the polygamma function of order m of z, psi^(m)(z). Special
cases are the digamma function (psi0), trigamma function (psi1),
tetragamma (psi2) and pentagamma (psi4) functions.</p>
<p>The parameter m should be a nonnegative integer.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.harmonic">
<!--[mpmath.functions.harmonic]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">harmonic</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>n</cite> is an integer, harmonic(<cite>n</cite>) gives a floating-point
approximation of the <cite>n</cite>-th harmonic number
H(<cite>n</cite>) = 1 + 1/2 + 1/3 + ... + 1/<cite>n</cite>:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 0.0</span>
<span class="go">1 1.0</span>
<span class="go">2 1.5</span>
<span class="go">3 1.83333333333333</span>
<span class="go">4 2.08333333333333</span>
<span class="go">5 2.28333333333333</span>
<span class="go">6 2.45</span>
<span class="go">7 2.59285714285714</span>
</pre></div>
<p>The infinite harmonic series 1 + 1/2 + 1/3 + ... diverges:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">+inf</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">harmonic()</span></tt> is evaluated using the digamma function rather
than by summing the harmonic series term by term. It can therefore
be computed quickly for arbitrarily large <cite>n</cite>, and even for
nonintegral arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">100</span><span class="p">)</span>
<span class="go">230.835724964306</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.613705638880109</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">3</span><span class="o">+</span><span class="mf">4</span><span class="n">j</span><span class="p">)</span>
<span class="go">(2.24757548223494 + 0.850502209186044j)</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">harmonic()</span></tt> supports arbitrary precision evaluation:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">11</span><span class="p">)</span>
<span class="go">3.0198773448773448773448773448773448773448773448773</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.8727388590273302654363491032336134987519132374152</span>
</pre></div>
<p>The harmonic series diverges, but at a glacial pace. It is possible
to calculate the exact number of terms required before the sum
exceeds a given amount, say 100:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="mf">10</span><span class="o">**</span><span class="n">findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">harmonic</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">100</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span>
<span class="go">15092688622113788323693563264538101449859496.864101</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">v</span>
<span class="go">15092688622113788323693563264538101449859497</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">99.999999999999999999999999999999999999999999942747</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">harmonic</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">100.000000000000000000000000000000000000000000009</span>
</pre></div>
</dd></dl>

</div>
<div class="section" id="riemann-zeta-function-bernoulli-numbers-and-related">
<h2><a class="toc-backref" href="#id10">Riemann zeta function, Bernoulli numbers and related<a class="headerlink" href="#riemann-zeta-function-bernoulli-numbers-and-related" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.zeta">
<!--[mpmath.functions.zeta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">zeta</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Riemann zeta function, zeta(s). The Riemann zeta
function is defined for Re(s) &gt; 1 by:</p>
<pre>                 -s     -s     -s
zeta(s) = 1  +  2   +  3   +  4   + ...</pre>
<p>and for Re(s) &lt;= 1 by analytic continuation. It has a pole
at s = 1.</p>
<p><strong>Examples</strong></p>
<p>Some exact values of the zeta function are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span><span class="o">**</span><span class="mf">2</span> <span class="o">/</span> <span class="mf">6</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">-0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0833333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">zeta()</span></tt> supports arbitrary precision evaluation and
complex arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.1762417383825827588721504519380520911697389900217</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">1</span><span class="o">+</span><span class="mf">2</span><span class="n">j</span><span class="p">)</span>  <span class="c"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="go">(0.5981655697623817367034568491742186771747764868876 -</span>
<span class="go">0.35185474521784529049653859679690026505229177886045j)</span>
</pre></div>
<p>The Riemann zeta function has so-called nontrivial zeros on
the critical line s = 1/2 + j*t:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">14</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 14.1347251417347j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">21</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 21.0220396387716j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">findroot</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">25</span><span class="n">j</span><span class="p">)</span>
<span class="go">(0.5 + 25.0108575801457j)</span>
</pre></div>
<p>For large positive s, zeta(s) rapidly approaches 1:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">1.00000000093133</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
<p>The following series converges and in fact has a simple
closed form value:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sumsh</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">zeta</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1</span><span class="p">,</span> <span class="p">[</span><span class="mf">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
</pre></div>
<p><strong>Algorithm</strong></p>
<p>The primary algorithm is Borwein&#8217;s algorithm for the Dirichlet
eta function. Three separate implementations are used: for general
real arguments, general complex arguments, and for integers. The
reflection formula is applied to arguments in the negative
half-plane. For very large real arguments, either direct
summation or the Euler prime product is used.</p>
<p>It should be noted that computation of zeta(s) gets very slow
when s is far away from the real axis.</p>
<p><strong>References</strong></p>
<ul class="simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/RiemannZetaFunction.html">http://mathworld.wolfram.com/RiemannZetaFunction.html</a></li>
<li><a class="reference external" href="http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf">http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf</a></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.altzeta">
<!--[mpmath.functions.altzeta]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">altzeta</tt><big>(</big><em>x</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.altzeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Dirichlet eta function, eta(s), also known as the
alternating zeta function. This function is defined in analogy
with the Riemann zeta function as providing the sum of the
alternating series:</p>
<pre>                -s     -s     -s
eta(s) = 1  -  2   +  3   -  4   + ...</pre>
<p>Note that eta(1) = log(2) is the alternating harmonic series.
The eta function unlike the Riemann zeta function is an entire
function, having a finite value for all complex s.</p>
<p>The alternating and non-alternating zeta functions are related
via the simple formula:</p>
<div class="highlight"><pre><span class="n">eta</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="mf">2</span><span class="o">^</span><span class="p">(</span><span class="mf">1</span><span class="o">-</span><span class="n">s</span><span class="p">))</span> <span class="o">*</span> <span class="n">zeta</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
<p>This formula can be used to define eta(s) for Re(s) &lt;= 0,
where the series diverges.</p>
<p><strong>Examples</strong></p>
<p>Some special values are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.693147180559945</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="o">-</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
<p>An example of a sum that can be computed more accurately and
efficiently via <tt class="xref docutils literal"><span class="pre">altzeta()</span></tt> than via numerical summation:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mf">2.5</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">100</span><span class="p">))</span>
<span class="go">0.86720495150398402</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
<span class="go">0.867199889012184</span>
</pre></div>
<p>At positive even integers, the Dirichlet eta function
evaluates to a rational multiple of a power of pi:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">0.822467033424113</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pi</span><span class="o">**</span><span class="mf">2</span><span class="o">/</span><span class="mf">12</span>
<span class="go">0.822467033424113</span>
</pre></div>
<p>Like the Riemann zeta function, eta(s), approaches 1
as s approaches positive infinity, although it does
so from below rather than from above:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">0.999999999068682</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">altzeta</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;0.99999999999999989&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="go">mpf(&#39;1.0&#39;)</span>
</pre></div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/DirichletEtaFunction.html">http://mathworld.wolfram.com/DirichletEtaFunction.html</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Dirichlet_eta_function">http://en.wikipedia.org/wiki/Dirichlet_eta_function</a></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.bernoulli">
<!--[mpmath.functions.bernoulli]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">bernoulli</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the nth Bernoulli number, B(n), for any integer n &gt;= 0.</p>
<p>The Bernoulli numbers are rational numbers, but this function
returns a floating-point approximation. To obtain an exact
fraction, use <tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> instead.</p>
<p><strong>Examples</strong></p>
<p>Numerical values of the first few Bernoulli numbers:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">15</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="n">bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 1.0</span>
<span class="go">1 -0.5</span>
<span class="go">2 0.166666666666667</span>
<span class="go">3 0.0</span>
<span class="go">4 -0.0333333333333333</span>
<span class="go">5 0.0</span>
<span class="go">6 0.0238095238095238</span>
<span class="go">7 0.0</span>
<span class="go">8 -0.0333333333333333</span>
<span class="go">9 0.0</span>
<span class="go">10 0.0757575757575758</span>
<span class="go">11 0.0</span>
<span class="go">12 -0.253113553113553</span>
<span class="go">13 0.0</span>
<span class="go">14 1.16666666666667</span>
</pre></div>
<p>Bernoulli numbers can be approximated with arbitrary precision:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">-2.8382249570693706959264156336481764738284680928013e+78</span>
</pre></div>
<p>Arbitrarily large n are supported:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">20</span> <span class="o">+</span> <span class="mf">2</span><span class="p">)</span>
<span class="go">3.09136296657021e+1876752564973863312327</span>
</pre></div>
<p>The Bernoulli numbers are related to the Riemann zeta function
at integer arguments:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="o">-</span><span class="n">bernoulli</span><span class="p">(</span><span class="mf">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mf">8</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="mf">8</span><span class="p">))</span>
<span class="go">1.00407735619794</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">zeta</span><span class="p">(</span><span class="mf">8</span><span class="p">)</span>
<span class="go">1.00407735619794</span>
</pre></div>
<p><strong>Algorithm</strong></p>
<p>For small n (n &lt; 3000) <tt class="xref docutils literal"><span class="pre">bernoulli()</span></tt> uses a recurrence
formula due to Ramanujan. All results in this range are cached,
so sequential computation of small Bernoulli numbers is
guaranteed to be fast.</p>
<p>For larger n, B(n) is evaluated in terms of the Riemann zeta
function.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.bernfrac">
<!--[mpmath.functions.bernfrac]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">bernfrac</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.bernfrac" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of integers (p, q) such that p/q = B(n) exactly,
where B(n) denotes the nth Bernoulli number. The fraction is
always reduced to lowest terms. Note that for n &gt; 1 and n odd,
B(n) = 0, and (0, 1) is returned.</p>
<p><strong>Examples</strong></p>
<p>The first few Bernoulli numbers are exactly:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">15</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">bernfrac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 1/1</span>
<span class="go">1 -1/2</span>
<span class="go">2 1/6</span>
<span class="go">3 0/1</span>
<span class="go">4 -1/30</span>
<span class="go">5 0/1</span>
<span class="go">6 1/42</span>
<span class="go">7 0/1</span>
<span class="go">8 -1/30</span>
<span class="go">9 0/1</span>
<span class="go">10 5/66</span>
<span class="go">11 0/1</span>
<span class="go">12 -691/2730</span>
<span class="go">13 0/1</span>
<span class="go">14 7/6</span>
</pre></div>
<p>This function works for arbitrarily large n:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">bernfrac</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">q</span>
<span class="go">2338224387510</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">27692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mpf</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">q</span>
<span class="go">-9.04942396360948e+27677</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">bernoulli</span><span class="p">(</span><span class="mf">10</span><span class="o">**</span><span class="mf">4</span><span class="p">)</span>
<span class="go">-9.04942396360948e+27677</span>
</pre></div>
<p>Note: <tt class="xref docutils literal"><span class="pre">bernoulli()</span></tt> computes a floating-point approximation
directly, without computing the exact fraction first.
This is much faster for large n.</p>
<p><strong>Algorithm</strong></p>
<p><tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> works by computing the value of B(n) numerically
and then using the von Staudt-Clausen theorem [1] to reconstruct
the exact fraction. For large n, this is significantly faster than
computing B(1), B(2), ..., B(n) recursively with exact arithmetic.
The implementation has been tested for B(10**n) up to n = 6.</p>
<p>In practice, <tt class="xref docutils literal"><span class="pre">bernfrac()</span></tt> appears to be about three times
slower than the specialized program calcbn.exe [2]</p>
<p><strong>References</strong></p>
<dl class="docutils">
<dt>[1] MathWorld, von Staudt-Clausen Theorem:</dt>
<dd><a class="reference external" href="http://mathworld.wolfram.com/vonStaudt-ClausenTheorem.html">http://mathworld.wolfram.com/vonStaudt-ClausenTheorem.html</a></dd>
<dt>[2] The Bernoulli Number Page:</dt>
<dd><a class="reference external" href="http://www.bernoulli.org/">http://www.bernoulli.org/</a></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.stieltjes">
<!--[mpmath.functions.stieltjes]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">stieltjes</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#mpmath.functions.stieltjes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a nonnegative integer <cite>n</cite>, stieltjes(<cite>n</cite>) computes the
nth Stieltjes constant, defined as the nth coefficient
in the Laurent series expansion of the Riemann zeta function
around the pole at s = 1:</p>
<pre>                    oo
                    ___     n
            1      \    (-1)                n
zeta(s) = ----- +   )   ----- (gamma ) (s-1)
          s - 1    /___  n!         n
                   n = 0</pre>
<p>Here gamma_n is the nth Stieltjes constant.</p>
<p><strong>Examples</strong></p>
<p>The zeroth Stieltjes constant is just Euler&#8217;s constant:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">0.577215664901533</span>
</pre></div>
<p>Some more values are:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0728158454836767</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
<span class="go">0.000205332814909065</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
<span class="go">0.00355772885557316</span>
</pre></div>
<p>An alternative way to compute gamma_1:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">diff</span><span class="p">(</span><span class="n">extradps</span><span class="p">(</span><span class="mf">25</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">-0.0728158454836767</span>
</pre></div>
<p><tt class="xref docutils literal"><span class="pre">stieltjes()</span></tt> supports arbitrary precision evaluation,
and caches computed results:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">stieltjes</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="go">-0.0096903631928723184845303860352125293590658061013408</span>
</pre></div>
<p><strong>Algorithm</strong></p>
<p>The calculation is done using numerical differentiation
for very small n (currently n = 1-3).</p>
<p>For larger n, integration of the Riemann zeta function is
used. The method should work for any <cite>n</cite> and dps, but soon
becomes quite slow in practice. The code has been tested
with n = 50 and dps = 100; that computation took about
2 minutes.</p>
<p><strong>References</strong></p>
<ul class="simple">
<li><a class="reference external" href="http://mathworld.wolfram.com/StieltjesConstants.html">http://mathworld.wolfram.com/StieltjesConstants.html</a></li>
<li><a class="reference external" href="http://pi.lacim.uqam.ca/piDATA/stieltjesgamma.txt">http://pi.lacim.uqam.ca/piDATA/stieltjesgamma.txt</a></li>
</ul>
</dd></dl>

</div>
<div class="section" id="hypergeometric-functions">
<h2><a class="toc-backref" href="#id11">Hypergeometric functions<a class="headerlink" href="#hypergeometric-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.hyper">
<!--[mpmath.functions.hyper]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyper</tt><big>(</big><em>a_s</em>, <em>b_s</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyper" title="Permalink to this definition">¶</a></dt>
<dd><p>Hypergeometric function pFq:</p>
<pre>    [ a_1, a_2, ..., a_p |    ]
pFq [                    |  z ]
    [ b_1, b_2, ..., b_q |    ]</pre>
<p>The parameter lists a_s and b_s may contain real or complex numbers.
Exact rational parameters can be given as tuples (p, q).</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp0f1">
<!--[mpmath.functions.hyp0f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp0f1</tt><big>(</big><em>a</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp0f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 0F1. hyp0f1(a,z) is equivalent
to hyper([], [a], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp1f1">
<!--[mpmath.functions.hyp1f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp1f1</tt><big>(</big><em>a</em>, <em>b</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp1f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 1F1. hyp1f1(a,b,z) is equivalent
to hyper([a], [b], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.hyp2f1">
<!--[mpmath.functions.hyp2f1]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">hyp2f1</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>z</em><big>)</big><a class="headerlink" href="#mpmath.functions.hyp2f1" title="Permalink to this definition">¶</a></dt>
<dd>Hypergeometric function 2F1. hyp2f1(a,b,c,z) is equivalent
to hyper([a,b], [c], z); see documentation for hyper() for more
information.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.jacobi">
<!--[mpmath.functions.jacobi]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">jacobi</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.jacobi" title="Permalink to this definition">¶</a></dt>
<dd>Jacobi polynomial P_n^(a,b)(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.legendre">
<!--[mpmath.functions.legendre]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">legendre</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.legendre" title="Permalink to this definition">¶</a></dt>
<dd>Legendre polynomial P_n(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chebyt">
<!--[mpmath.functions.chebyt]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chebyt</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chebyt" title="Permalink to this definition">¶</a></dt>
<dd>Chebyshev polynomial of the first kind T_n(x).</dd></dl>

<dl class="function">
<dt id="mpmath.functions.chebyu">
<!--[mpmath.functions.chebyu]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">chebyu</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.chebyu" title="Permalink to this definition">¶</a></dt>
<dd>Chebyshev polynomial of the second kind U_n(x).</dd></dl>

</div>
<div class="section" id="elliptic-functions">
<h2><a class="toc-backref" href="#id12">Elliptic functions<a class="headerlink" href="#elliptic-functions" title="Permalink to this headline">¶</a></a></h2>
<dl class="function">
<dt id="mpmath.functions.agm">
<!--[mpmath.functions.agm]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">agm</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.agm" title="Permalink to this definition">¶</a></dt>
<dd><p>agm(a, b) computes the arithmetic-geometric mean of a and b,
defined as the limit of the iteration a, b = (a+b)/2, sqrt(a*b).</p>
<p>This function can be called with a single argument, computing
agm(a,1) = agm(1,a).</p>
<p><strong>Examples</strong></p>
<p>A formula for gamma(1/4):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">mpmath</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mf">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">gamma</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">3.62560990822191</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mf">3</span><span class="p">)</span><span class="o">/</span><span class="n">agm</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2</span><span class="p">)))</span>
<span class="go">3.62560990822191</span>
</pre></div>
<p><strong>Possible issues</strong></p>
<p><tt class="xref docutils literal"><span class="pre">agm()</span></tt> may not give an appropriate branch for complex
arguments a and b.</p>
</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ellipe">
<!--[mpmath.functions.ellipe]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ellipe</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ellipe" title="Permalink to this definition">¶</a></dt>
<dd>Complete elliptic integral of the second kind, E(m). Note that
the argument is the parameter m = k^2, not the modulus k.</dd></dl>

<dl class="function">
<dt id="mpmath.functions.ellipk">
<!--[mpmath.functions.ellipk]--><tt class="descclassname">mpmath.functions.</tt><tt class="descname">ellipk</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.functions.ellipk" title="Permalink to this definition">¶</a></dt>
<dd>Complete elliptic integral of the first kind, K(m). Note that
the argument is the parameter m = k^2, not the modulus k.</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jtheta">
<!--[mpmath.elliptic.jtheta]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jtheta</tt><big>(</big><em>n</em>, <em>z</em>, <em>q</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jtheta" title="Permalink to this definition">¶</a></dt>
<dd><p>Jacobi theta functions as functions of the nome q
n = 1,2,3,4
z complex number
q complex number in the unit disk</p>
<p>Definition:</p>
<pre>theta(1, z, q) =
  2 * q**1/4 * Sum((-)**n * q**(n*n + n) * sin((2*n + 1)*z), n=0, inf)

theta(2, z, q) =
  2 * q**1/4 * Sum(q**(n*n + n) * cos((2*n + 1)*z), n=0, inf)

theta(3, z, q) = 1 + 2 * Sum(q**(n**2) * cos(2*n*z), n=1, inf)

theta(4, z, q) = 1 + 2 * Sum((-q)**(n**2) * cos(2*n*z), n=1, inf)</pre>
</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.djtheta">
<!--[mpmath.elliptic.djtheta]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">djtheta</tt><big>(</big><em>n</em>, <em>z</em>, <em>q</em>, <em>nd=1</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.djtheta" title="Permalink to this definition">¶</a></dt>
<dd>ndth derivative of the Jacobi theta functions jtheta(n, z, q)
with respect to z
n = 1,2,3,4
z complex number
q complex number in the unit disk
nd &gt;= 1</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jsn">
<!--[mpmath.elliptic.jsn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jsn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jsn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic sn function in term
of jacoby theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jcn">
<!--[mpmath.elliptic.jcn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jcn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jcn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic cn function in term
of theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

<dl class="function">
<dt id="mpmath.elliptic.jdn">
<!--[mpmath.elliptic.jdn]--><tt class="descclassname">mpmath.elliptic.</tt><tt class="descname">jdn</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#mpmath.elliptic.jdn" title="Permalink to this definition">¶</a></dt>
<dd>Implementation of the jacobi elliptic dn function in term
of theta functions.
u is any complex number, m must be in the unit disk</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">Mathematical functions</a><ul>
<li><a class="reference external" href="#constants">Constants</a></li>
<li><a class="reference external" href="#number-parts">Number parts</a></li>
<li><a class="reference external" href="#powers-and-logarithms">Powers and logarithms</a></li>
<li><a class="reference external" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference external" href="#hyperbolic-functions">Hyperbolic functions</a></li>
<li><a class="reference external" href="#exponential-integrals">Exponential integrals</a></li>
<li><a class="reference external" href="#bessel-and-related-functions">Bessel and related functions</a></li>
<li><a class="reference external" href="#gamma-and-related-functions">Gamma and related functions</a></li>
<li><a class="reference external" href="#riemann-zeta-function-bernoulli-numbers-and-related">Riemann zeta function, Bernoulli numbers and related</a></li>
<li><a class="reference external" href="#hypergeometric-functions">Hypergeometric functions</a></li>
<li><a class="reference external" href="#elliptic-functions">Elliptic functions</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="basics.html" title="previous chapter">Mpmath basics</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="calculus.html" title="next chapter">Numerical calculus</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/functions.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="calculus.html" title="Numerical calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basics.html" title="Mpmath basics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">mpmath v0.10-svn documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Fredrik Johansson.
      Last updated on Nov 07, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>

<!-- Generate pageview statistics when this document is viewed on the mpmath website -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">

if ((""+document.location).match("google"))
{
    _uacct = "UA-2697185-2";
    urchinTracker();
}
</script>
  </body>
</html>