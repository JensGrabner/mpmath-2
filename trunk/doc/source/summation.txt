Summation
=========

Rapidly convergent infinite series are easy to approximate by directly summing a finite number of terms:

    >>> from mpmath import *
    >>> mp.dps = 50
    >>> print sum(1/factorial(n) for n in range(100))
    2.7182818284590452353602874713526624977572470936999

This is not practical if the series converges less than geometrically (meaning that the remainder after ``n`` terms is of order ``c**(-n)`` for some positive constant ``c``). Slowly convergent series can nevertheless often be summed numerically to high precision by applying a suitable transformation that accelerates the rate of convergence. Mpmath implements three such algorithms.

Euler-Maclaurin summation (``sumem``)
-------------------------------------

``sumem(f, a, b)`` calculates the sum of ``f(n)`` for ``n = a..b`` using Euler-Maclaurin summation. This algorithm is useful for summation of infinite series that converge slowly; the essential condition is that f must be analytic (holomorphic). 

    >>> mp.dps = 15
    >>> print sumem(lambda n: 1/n**2, 1, inf)
    1.64493406684823
    >>> print pi**2 / 6
    1.64493406684823

The parameter ``N`` optionally specifies the number of terms to compute directly before using the Euler-Maclaurin formula to approximate the tail. It must be set high enough; often roughly ``N`` ~ ``dps`` is the right size.

The method relies on approximating the sum by an integral, so ``f`` must be smooth and well-behaved enough to be integrated numerically. High-order derivatives of f are also needed. By default, these are computed using numerical integration, which is the most expensive part of the calculation. A custom nth derivative function ``fderiv(x, n)`` can be provided as a keyword parameter; if the derivatives are known analytically, this is generally much more efficient, enabling relatively fast summations to tens or hundreds of digits:

    >>> f = lambda n: 1/n**2
    >>> fp = lambda x, n: (-1)**n * factorial(n+1) * x**(-2-n)
    >>> mp.dps = 50
    >>> print sumem(lambda n: 1/n**2, 1, inf, fderiv=fp)
    1.6449340668482264364724151666460251892189499012068
    >>> print pi**2 / 6
    1.6449340668482264364724151666460251892189499012068

If ``b = inf``, ``f`` and its derivatives are all assumed to vanish at infinity (this method is therefore not good for alternating sums). It is assumed that ``a`` is finite, so doubly infinite sums cannot be evaluated directly.

With error=True, a tuple (s, err) is returned where s is the calculated sum and err is the estimated magnitude of the error. With verbose=True, detailed information about progress and errors is printed.

Shanks summation (``sumsh``)
----------------------------

Richardson summation (``sumrich``)
----------------------------------

